<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Alfonso Miranda</title><description>Mobile Software Engineer</description><link>https://alfonsomiranda.com</link><language>es</language><lastBuildDate>Tue, 16 Nov 2021 20:03:09 +0100</lastBuildDate><pubDate>Tue, 16 Nov 2021 20:03:09 +0100</pubDate><ttl>250</ttl><atom:link href="https://alfonsomiranda.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://alfonsomiranda.com/posts/integration_with_bitrise</guid><title>Validación de código con github y bitrise</title><description>Bitrise es una herramienta que nos facilita mucho la integración contínua orientada a entornos de movilidad. Con ella podemos automatizar nuestra validación, compilación y distribución, entre otras muchas cosas. En este artículo nos vamos a centrar en como usar un flujo creado en bitrise para una validación automática previa en una revisión de código.</description><link>https://alfonsomiranda.com/posts/integration_with_bitrise</link><pubDate>Wed, 10 Nov 2021 13:30:00 +0100</pubDate><content:encoded><![CDATA[<p><a href="https://www.bitrise.io/">Bitrise</a> es una herramienta que nos facilita mucho la integración contínua orientada a entornos de movilidad. Con ella podemos automatizar nuestra validación, compilación y distribución, entre otras muchas cosas. En este artículo nos vamos a centrar en como usar un flujo creado en bitrise para una validación automática previa en una revisión de código.</p><h1>Creando un nuevo proyecto en bitrise</h1><p>Bitrise tiene diferentes planes, pero tiene uno para comenzar que es gratuito, así que nos podemos crear una cuenta para ir probándolo. Una vez creada empezamos a crear una nueva app y nos encontramos esto:</p><img src="https://alfonsomiranda.com/images/bitrise/new-project-bitrise.png" alt="New project bitrise" width="800"/><p>En mi caso ya tenía añadida mi cuenta de github y puedo navegar por mis repositorios, si tú aún no lo tienes sigue las instrucciones que te indican en bitrise para hacerlo.</p><p>Para este artículo vamos a continuar con el proyecto que empezamos en el anterior, donde <a href="https://alfonsomiranda.com/posts/component-swift-package-manager/">distribuíamos un componente por Swift Package Manager</a>. Una vez seleccionado el repositorio, indicamos de qué rama queremos hacer la integración. En mi caso he elegido main y al darle a continuar empieza el proceso para configurarlo ... ¡y nos dará error!</p><p>¿Por qué?</p><p>Porque nuestro proyecto no es un proyecto "Xcode" normal, no tenemos un ejecutable definido, un xcodeproj o xcworkspace, así que tenemos que hacerlo.</p><p>Nos vamos a donde está nuestro proyecto y por línea de comandos ejecutamos lo siguiente:</p><pre><code>swift package generate-xcodeproj
</code></pre><p>que nos genera un xcodeproj.</p><p>Al abrirlo vamos a mirar los esquemas y quedarnos con el nombre, que será importante para configurarlo en bitrise.</p><img src="https://alfonsomiranda.com/images/bitrise/xcode-scheme.png" alt="Xcode scheme" width="800"/><p>Subimos los cambios al repositorio, volvemos a bitrise y hacemos de nuevo la configuración, pero elegimos la forma manual porque sigue fallando de forma automática (algún nombre de esquema o de proyecto que no detecta automáticamente), y habrá que configurar algunas cosillas. En primer lugar elegimos iOS y añadimos el xcodeproj</p><img src="https://alfonsomiranda.com/images/bitrise/bitrise-project-configuration.png" alt="Bitrise project configuration" width="800"/><p>E indicamos nuestro esquema.</p><img src="https://alfonsomiranda.com/images/bitrise/bitrise-scheme-configuration.png" alt="Bitrise scheme configuration" width="800"/><p>A continuación elegimos el método de distribución, en mi caso usaré development pero podéis poner el que queráis o modificarlo posteriormente. Y seleccionáis que máquina queréis usar.</p><img src="https://alfonsomiranda.com/images/bitrise/bitrise-configuration-xcode.png" alt="Bitrise xcode configuration" width="800"/><p>Confirmamos. Nos saltamos (si queremos) el paso de añadir el icono, y le damos a registrar un webhook, que añadirá a nuestro github el webhook necesario para que nos podamos comunicar con bitrise para la comprobación que haremos después en cada pull request.</p><p>Le damos a finalizar y empezará a intentar ejecutar nuestro workflow. En mi caso al menos falla porque, no sé la razón, por defecto me pone un paso para cocoapods, cosa que no tengo (ni quiero tener), así que lo elimino.</p><img src="https://alfonsomiranda.com/images/bitrise/bitrise-error-workflow.png" alt="Bitrise error workflow" width="800"/><p>Y volvemos a ejecutar el workflow y ¡se hace la magia!</p><p>Ahora vamos a integrar la comprobación de bitrise con la creación de una PR. La idea es que cuando alguien cree una nueva PR, a parte de otras validaciones necesarias (por ejemplo, un mínimo de aprobaciones por parte del equipo), sea obligatorio que nuestro workflow de bitrise pase sin errores. En bitrise ahora mismo solo tenemos añadido que el proyecto compile y que pase los tests, pero podemos añadir más cosas en el futuro.</p><p>En primer lugar, nos vamos a las settings de nuestro proyecto en bitrise</p><img src="https://alfonsomiranda.com/images/bitrise/bitrise-workflow-configuration.png" alt="Bitrise workflow configuration" width="800"/><p>y activamos la opción de "Enable Github checks".</p><img src="https://alfonsomiranda.com/images/bitrise/bitrise-enable-checks.png" alt="Bitrise enable checks" width="800"/><p>Si es la primera vez que lo hacemos en nuestro repositorio, primero será necesario instalar la app y dar permisos, como indica en el enlace bajo el checkbox.</p><p>Una vez hecho ya estará preparado para hacer esas comprobaciones.</p><img src="https://alfonsomiranda.com/images/bitrise/bitrise-enable-checks-2.png" alt="Bitrise enabled check" width="800"/><p>Si nos vamos a nuestro workflow, en la parte de triggers de pull request, veremos que se nos ha añadido un nuevo lanzador que saltará cuando se haga un pull request de cualquier rama hacia cualquier rama. Esto lo podemos especificar para que solo sea a una en concreto (por ejemplo a la rama main) o definir más de uno para que dependiendo de la rama destino se ejecute diferentes acciones. Por ahora lo dejaremos así.</p><img src="https://alfonsomiranda.com/images/bitrise/bitrise-triggers.png" alt="Bitrise triggers" width="800"/><h1>Configurando el repositorio</h1><p>Ahora nos vamos a nuestro repositorio, a la configuración y vamos a la sección de branches</p><img src="https://alfonsomiranda.com/images/bitrise/github-activate-bitrise-check.png" alt="Github bitrise check" width="800"/><p>Añadimos una nueva protección para nuestra rama principal, marcando "Add rule".</p><p>Aquí marcamos los siguientes checkbox para nuestra rama main:</p><img src="https://alfonsomiranda.com/images/bitrise/github-branch-protection-rule.png" alt="Github branch protection rule" width="800"/><p>donde hemos seleccionado que sea necesario que pase nuestros status check, en nuestro caso bitrise.</p><h1>Creando una nueva pull request</h1><p>En teoría está ya todo listo para que cualquier pull request lance la comprobación y nos bloquee el mergeo en caso de error. Vamos a probar creando una nueva rama con algún cambio, y lanzando una PR.</p><p>El cambio será de lo más tonto, en el único método que tenemos definido, en vez de tener un resultado de "Hello + name" tendremos "Hello, + name", de esta forma:</p><pre><code><span class="keyword">public struct</span> Matrix {
    <span class="keyword">public static func</span> hello(name: <span class="type">String</span>) -&gt; <span class="type">String</span> {
        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name
    }
}
</code></pre><p>Lo subimos en una nueva rama, nos vamos a github y creamos la PR:</p><img src="https://alfonsomiranda.com/images/bitrise/new-pull-request.png" alt="New pull request" width="800"/><img src="https://alfonsomiranda.com/images/bitrise/new-pull-request-2.png" alt="New pull request" width="800"/><p>Y al crear la PR vemos que se empieza a ejecutar el check de Bitrise.</p><img src="https://alfonsomiranda.com/images/bitrise/pull-request-checks.png" alt="Pull requests check" width="800"/><p>Entrando en los detalles incluso podemos acceder directamente a la ejecución de bitrise para ver el progreso, que tardará unos minutillos.</p><p>Cuando termina, ¡oh! ¡sorpresa! ... ha fallado.</p><img src="https://alfonsomiranda.com/images/bitrise/pull-request-fail.png" alt="Pull request fail" width="800"/><p>Vamos a ir a los detalles a ver qué ha pasado.</p><img src="https://alfonsomiranda.com/images/bitrise/pull-request-fail-summary.png" alt="Pull request summary fails" width="800"/><p>Vemos que, obviamente, han fallado los test, ya que hemos cambiado la implementación pero no hemos actualizado los tests. Bitrise nos ha salvado de mergear a master (o main en el caso de github) una versión con los tests fallando ya que hemos subido sin probar que los tests funcionaban (¡mal! ¡muy mal!)</p><p>Vamos a los test y los corregimos.</p><pre><code><span class="keyword">import</span> XCTest
<span class="keyword">@testable import</span> Matrix

<span class="keyword">final class</span> MatrixTests: <span class="type">XCTestCase</span> {
    <span class="keyword">func</span> testHello() <span class="keyword">throws</span> {
        <span class="call">XCTAssertEqual</span>(<span class="type">Matrix</span>.<span class="call">hello</span>(name: <span class="string">"Alfonso"</span>), <span class="string">"Hello, Alfonso"</span>)
    }
}
</code></pre><p>Y subimos a nuestra rama, que a su vez actualizará la PR y lanzará de nuevo bitrise.</p><p>¡Y ahora si pasa las validaciones!</p><img src="https://alfonsomiranda.com/images/bitrise/pull-request-success.png" alt="Pull request success" width="800"/><p>Podemos ver un resumen de nuestro workflow en los detalles.</p><img src="https://alfonsomiranda.com/images/bitrise/pull-request-summary-success.png" alt="Pull request summary success" width="800"/><p>Y de esta forma tan sencilla hemos añadido un validador automático a nuestras pull requests, muy útiles para que los diferentes revisores de nuestro código no se tengan que preocupar de si los tests se están cumpliendo o de diferentes temas que se pueden hacer de forma automática. En futuros artículos añadiremos a nuestro workflow más pasos muy necesarios e importantes, como un validador de código <code>swiftlint</code> o que pase una comprobación más por Sonar. Pero esto ya será para otro día.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://alfonsomiranda.com/posts/component-swift-package-manager</guid><title>Distribuir componentes con Swift Package Manager</title><description>Swift Package Manager es una herramienta para controlar la distribución de código Swift en forma de librería o framework. Está integrada con el sistema de compliación de Swift para automatizar el proceso de descarga, compilación y dependencias.</description><link>https://alfonsomiranda.com/posts/component-swift-package-manager</link><pubDate>Sun, 17 Oct 2021 13:30:00 +0200</pubDate><content:encoded><![CDATA[<p><a href="https://swift.org/package-manager/">Swift Package Manager</a> es una herramienta para controlar la distribución de código Swift en forma de librería o framework. Está integrada con el sistema de compliación de Swift para automatizar el proceso de descarga, compilación y dependencias. En este artículo me gustaría comentar el proceso, muy simple, de poder crear un componente en Swift para ser distribuido con Swift Package Manager.</p><h1>Creando un nuevo paquete</h1><p>La forma de crear un nuevo paquete es muy fácil. En primer lugar vamos a <code>File -&gt; New -&gt; Package...</code></p><img src="https://alfonsomiranda.com/images/spm/new-package.png" alt="New package" width="800"/><p>Ponemos un nombre y se crea un proyecto de tipo Swift Package Manager.</p><p>Una de las diferencias que tiene este tipo de proyecto es que no tenemos un fichero xcodeproj, si no que se abre con <code>open Package.swift</code>. De todas formas, se puede crear ese xcodeproj si lo necesitáramos, pero para lo que veremos aquí no hará falta hacerlo.</p><p>La estructura del proyecto queda de la siguiente forma.</p><img src="https://alfonsomiranda.com/images/spm/new-project-created.png" alt="New project" width="800"/><p>En el fichero <code>Package.swift</code> es donde tenemos toda la configuración del proyecto. Si necesitamos alguna otra dependencia, algún otro target o alguna cosa similar lo añadiríamos aquí. Por ahora no vamos a necesitar tocarlo.</p><p>Y en la carpeta <code>Sources</code> tendremos los ficheros de nuestro componente, con uno creado por defecto.</p><p>Como vemos en ese archivo, todo lo que hay declarado es público, y es muy importante que todo lo que queramos "exponer" y que sea consumido en los proyectos donde integremos nuestra librería tenga esta visibilidad.</p><p>Vamos a hacer un cambio en este archivo para poner un método estático que simplemente construya un <code>String</code> con <code>Hello + name</code>, de la siguiente forma:</p><pre><code><span class="keyword">public struct</span> Matrix {
    <span class="keyword">public static func</span> hello(name: <span class="type">String</span>) -&gt; <span class="type">String</span> {
        <span class="keyword">return</span> <span class="string">"Hello "</span> + name
    }
}
</code></pre><p>Modificamos también los tests para que no nos de error y quede todo nuestro proyecto testeado:</p><pre><code><span class="keyword">import</span> XCTest
<span class="keyword">@testable import</span> Matrix

<span class="keyword">final class</span> MatrixTests: <span class="type">XCTestCase</span> {
    <span class="keyword">func</span> testHello() <span class="keyword">throws</span> {
        <span class="call">XCTAssertEqual</span>(<span class="type">Matrix</span>.<span class="call">hello</span>(name: <span class="string">"Alfonso"</span>), <span class="string">"Hello Alfonso"</span>)
    }
}
</code></pre><h1>Subiendo el proyecto a un repositorio</h1><p>Con este pequeño componente empezaremos a trabajar y lo subiremos a nuestro repositorio para ver como se puede distribuir por SPM. Hay que subir el proyecto a la raiz de nuestro repositorio para que lo podamos consumir o si no nos daría problemas.</p><p>Una vez subido creamos un tag por consola de la siguiente forma, que será la versión empaquetada de nuestro componente.</p><pre><code>git tag -a <span class="number">1.0.0</span> -m <span class="string">"First version"</span>

git push origin <span class="number">1.0.0</span>
</code></pre><p>Y veremos en el repositorio que se ha creado y que ya tenemos una versión para poder utilizar.</p><img src="https://alfonsomiranda.com/images/spm/github-tag.png" alt="Github tag" width="800"/><p>Cada vez que queramos generar una nueva versión de nuestro componente usaremos esta forma para que después, a través de Swift Package Manager, podamos especificar y concretar con qué versión queremos trabajar, como veremos en el siguiente punto.</p><p>Ya lo tendríamos todo preparado para distribuirlo y consumirlo, no necesitamos nada más, vamos a ver como lo hacemos desde otro proyecto cualquiera.</p><h1>Usando el componente</h1><p>En el proyecto que queramos, vamos a File → Add Packages...</p><img src="https://alfonsomiranda.com/images/spm/add-packages.png" alt="Add package" width="800"/><p>Y ponemos la url de nuestro repositorio, y veremos que aparece nuestro componente.</p><img src="https://alfonsomiranda.com/images/spm/configure-package.png" alt="Configure package" width="800"/><p>Por defecto la regla de dependencia la tenemos puesta para que que se actualice solo cuando haya una versión major, pero podemos cambiarlo a minor, a una versión específica, a un rango de versiones e incluso a una rama o un commit. Lo vamos a dejar para que se actualice con cada nueva <code>minor version</code>.</p><p>Le damos a añadir el paquete y nos muestra los disponibles y seleccionamos el único que hemos creado.</p><img src="https://alfonsomiranda.com/images/spm/select-package.png" alt="Select package" width="800"/><p>Y ya lo tendremos en nuestro proyecto.</p><img src="https://alfonsomiranda.com/images/spm/package-inserted.png" alt="Package inserted" width="260" height="238"/><p>Ahora, donde lo queramos usar, importamos el paquete.</p><pre><code><span class="keyword">import</span> Matrix
</code></pre><p>Y usamos el método que creamos, por ejemplo en un label en SwiftUI de la siguiente forma:</p><img src="https://alfonsomiranda.com/images/spm/use-package.png" alt="How use package" width="800"/><p>Y de esta forma ya lo estamos usando en nuestro proyecto. A partir de aquí, si tenemos que hacer cualquier actualización de este componente en concreto, lo podremos hacer de forma totalmente separada y distribuirla cuando esté terminada, teniendo la opción los proyectos que la usen de actualizarse cuando esté lista la nueva versión.</p><p>Podéis ver el código del componente y su configuración en este <a href="https://github.com/alfonsomiranda/Matrix">repositorio</a>.</p><p>Próximamente, partiendo de este comienzo, hablaremos de como hacer una distribución más automatizada, ¡estad atentos!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://alfonsomiranda.com/posts/initialization-to-ar</guid><title>ARKit y RealitityKit: Inicialización a AR en iOS</title><description>La realidad aumentada existe desde hace muchos años. En iOS tomó especial fuerza cuando en 2017 Apple presentó su framework ARKit. Vamos a ver en qué estado está actualmente, qué podemos hacer y veremos RealitityKit, herramienta de modelado 3D que nos ayuda a potenciar nuestros desarrollos de AR.</description><link>https://alfonsomiranda.com/posts/initialization-to-ar</link><pubDate>Wed, 19 May 2021 12:15:00 +0200</pubDate><content:encoded><![CDATA[<p>La realidad aumentada existe desde hace muchos años. En iOS tomó especial fuerza cuando en 2017 Apple presentó su framework ARKit. Vamos a ver en qué estado está actualmente, qué podemos hacer y veremos RealitityKit, herramienta de modelado 3D que nos ayuda a potenciar nuestros desarrollos de AR.</p><h1>Creando un proyecto AR</h1><p>Para empezar vamos a crear un nuevo proyecto ARKit seleccionando la opción correspondiente.</p><img src="https://alfonsomiranda.com/images/arkit/createARProject.png" alt="Create AR project" width="800"/><p>Podemos elegir entre varias tecnologías para el contenido, es decir, para nuestra parte virtual. Hasta no hace mucho solo teníamos SceneKit (para modelos 3D), SpriteKit (para modelos 2D) y metal. Recientemente se añadió RealityKit, el cual está especializado para funcionar con realidad aumentada, así que será el que elegiremos.</p><img src="https://alfonsomiranda.com/images/arkit/createProjectSelectRealityKit.png" alt="Select RealityKit" width="800"/><p>Después podemos elegir si trabajar con Storyboard o SwiftUI. Vamos a seleccionar SwiftUI, que es el presente/futuro y nos tenemos que acostumbrar a trabajar con él.</p><img src="https://alfonsomiranda.com/images/arkit/selectSwiftUI.png" alt="Select SwiftUI" width="800"/><p>Y listo, creamos el proyecto y ya tenemos una base con un desarrollo que nos puede servir para ver como funciona de forma básica un proyecto de realidad aumentada.</p><p>En ContentView vemos una de las partes importantes. En primer lugar importamos, en nuestro caso, tanto SwiftUI y RealityKit.</p><pre><code><span class="keyword">import</span> SwiftUI
<span class="keyword">import</span> RealityKit
</code></pre><p>Después nuestra vista será un ARViewContainer, que como su nombre indica será el contenedor de nuestra realidad aumentada, y lo añadimos en nuestra View.</p><pre><code><span class="keyword">struct</span> ContentView : <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">ARViewContainer</span>().<span class="call">edgesIgnoringSafeArea</span>(.<span class="dotAccess">all</span>)
    }
}
</code></pre><p>Y definimos nuestro ARViewContainer de la siguiente forma, en este caso, en el ejemplo básico, cargando un objeto y añadiéndolo en nuestra escena.</p><pre><code><span class="keyword">struct</span> ARViewContainer: <span class="type">UIViewRepresentable</span> {
    
    <span class="keyword">func</span> makeUIView(context: <span class="type">Context</span>) -&gt; <span class="type">ARView</span> {
        
        <span class="keyword">let</span> arView = <span class="type">ARView</span>(frame: .<span class="dotAccess">zero</span>)
        
        <span class="comment">// Load the "Box" scene from the "Experience" Reality File</span>
        <span class="keyword">let</span> boxAnchor = <span class="keyword">try</span>! <span class="type">Experience</span>.<span class="call">loadBox</span>()
        
        <span class="comment">// Add the box anchor to the scene</span>
        arView.<span class="property">scene</span>.<span class="property">anchors</span>.<span class="call">append</span>(boxAnchor)
        
        <span class="keyword">return</span> arView
        
    }
    
    <span class="keyword">func</span> updateUIView(<span class="keyword">_</span> uiView: <span class="type">ARView</span>, context: <span class="type">Context</span>) {}
    
}
</code></pre><p>Pero ... ¿de dónde se está cargando ese objeto? ¿qué es ese objeto llamado 'Experience'?</p><p>Esta es la segunda cosa importante que tenemos que ver, es el fichero Experience.rcproject, que si lo abrimos vemos lo siguiente.</p><img src="https://alfonsomiranda.com/images/arkit/experienceProject.png" alt="experience.project" width="800"/><p>Es nuestro editor del mundo virtual que vamos a pintar en nuestra realidad. En el ejemplo básico, tan solo tenemos un cubo en el centro de nuestro mundo, que si ejecutamos el proyecto (recordemos que solo funciona en dispositivo) veremos el resultado.</p><img src="https://alfonsomiranda.com/images/arkit/cubeAR.jpeg" alt="Cube in AR" width="800"/><p>En la esquina superior derecha veremos un botón "Open in Reality Composer", y ahí tenemos el tercer elemento importante para empezar a construir apps de AR.</p><p>Abrimos el archivo con Reality Composer y podremos empezar a editar, añadir y crear mundos virtuales. Vamos a ver varios ejemplos de lo que podemos hacer.</p><img src="https://alfonsomiranda.com/images/arkit/sceneHorizontal.png" alt="Horizontal scene" width="800"/><p>Como vemos, tenemos nuestro cubo virtual que ya vimos como único elemento en nuestra única escena. Si vemos el nombre de la escena es "Box", y si recordamos, en el código para cargar el archivo era de la siguiente forma.</p><pre><code><span class="keyword">let</span> boxAnchor = <span class="keyword">try</span>! <span class="type">Experience</span>.<span class="call">loadBox</span>()
</code></pre><p>Lo iremos viendo, pero el patrón sería similar con las diferentes escenas que creemos, y podremos acceder a ellas con un método 'loadNombreEscena()'</p><p>Si miramos en la parte derecha, en el menú, podemos ver varias cosas interesantes. En primer lugar tenemos diferentes tipos de escena.</p><p>La que tenemos creada es horizontal, que significa que el objeto lo pinta en un plano horizontal que detecte. Como hemos visto, nuestro cubo se ha añadido en una mesa, detectándola como un plano horizontal.</p><p>La segunda opción es 'Vertical", y funciona de forma similar pero detectando un plano vertical, y podemos hacer la prueba poniendo un objeto y al detectar una pared lo añadirá a la realidad.</p><p>La tercera opción es el reconocimiento de una imagen. En esta opción nos podemos parar un poquito y vamos a crear una escena.</p><img src="https://alfonsomiranda.com/images/arkit/imageScene.png" alt="Image recognization scene" width="800"/><img src="https://alfonsomiranda.com/images/arkit/imageRecognizationScene.png" alt="Image recognization scene" width="800"/><p>Nos añade dos elementos a la escena, una especie de plano horizontal y un objeto 3D. En la derecha vemos que podemos seleccionar una imagen para ese plano, que será el que nos detecte. Esta imagen tiene que tener unas características concreta, una diferencia de colores y formas concretas que sean suficientes para reconocer la imagen. Si añadimos una imagen no válida nos avisará.</p><img src="https://alfonsomiranda.com/images/arkit/imageRecognizationError.png" alt="Image recognization scene error" width="800"/><p>Pero si encontramos una óptimas lo añadirá sin más problema.</p><img src="https://alfonsomiranda.com/images/arkit/imageRecognizationSuccess.png" alt="Image recognization scene success" width="800"/><p>Y si ejecutamos este proyecto podemos ver en el siguiente video como reconoce la imagen y añade el modelo que hemos definido.</p><video width="800" height="800" controls>
  <source src="https://alfonsomiranda.com/videos/imageRecognization.mp4" type="video/mp4">
</video><p>Nos quedarían dos tipos de escenas más, reconocimiento de caras y reconocimiento de objetos, pero da para un artículo cada uno que veremos próximamente.</p><p>Hasta ahora no hemos añadido más objetos que el que nos crea por defecto. Si le damos al "+" (añadir) que tenemos en la parte superior nos saldrá un selector donde podremos elegir entre un buen banco de modelos que nos proporciona Apple, desde figuras básicas como elementos comunes. Además, podemos importar nuestros propios modelos. Estos modelos deberían estar en formato usdz, pero si lo tenemos en otro tipo que sea compatible podríamos convertirlo con la herramienta <a href="https://developer.apple.com/news/?id=01132020a&1578956733">usdzconverter</a> o en esta <a href="página online">https://spase.io/playground</a> de forma mucho más cómoda.</p><img src="https://alfonsomiranda.com/images/arkit/addModels.png" alt="Add models" width="800"/><p>Existen más elementos relacionados con la física, materiales, gravedad y comportamientos muy interesantes, así como oclusión, que veremos en otro artículo más avanado.</p><p>Si queréis, en este directo que hice en <a href="twitch">http://twitch.alfonsomiranda.com</a> y que está en <a href="https://www.youtube.com/watch?v=YzssNbP5q8Q&ab_channel=Serquo">Youtube</a> podéis ver más tranquilamente lo escrito aquí y un poquito más.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://alfonsomiranda.com/posts/tdd-swift-clean-architecture</guid><title>TDD en Swift con Clean Architecture</title><description>TDD, Test Driven Development o Desarrollo guiado por pruebas es una forma o práctica de desarrollo donde, a muy grandes rasgos, se escriben las pruebas y a partir de ella se va implementando el código. La forma de hacer esto es ir creando las pruebas, que estas vayan fallando e ir arreglándolas refactorizando y creando el código necesario.</description><link>https://alfonsomiranda.com/posts/tdd-swift-clean-architecture</link><pubDate>Mon, 12 Apr 2021 17:06:00 +0200</pubDate><content:encoded><![CDATA[<p>TDD, Test Driven Development o Desarrollo guiado por pruebas es una forma o práctica de desarrollo donde, a muy grandes rasgos, se escriben las pruebas y a partir de ella se va implementando el código. La forma de hacer esto es ir creando las pruebas, que estas vayan fallando e ir arreglándolas refactorizando y creando el código necesario.</p><p>Estas pruebas suelen ser tests unitarios, y cómo ya vimos en el <a href="https://alfonsomiranda.com/posts/tests-swift-basic-concepts/">anterior artículo</a>, es algo bastante sencillo y necesario.</p><h1>Ventajas</h1><ul><li><strong>No se nos olvida hacer los tests</strong>. Esta es la razón más obvia. Una de las excusas más usada para hacer tests es el tiempo que conllevan y, como lo dejamos para el final, no nos termina de encajar en el deadline que tengamos en el proyecto, además de quizás darnos mucha pereza hacerlo. Con esta metodología, cuando acabamos la implementación ya tenemos los tests hechos y con el deber de buen desarrollador cumplido.</li><li><strong>Evitamos código innecesario</strong>. Como veremos más adelante, TDD es algo más que escribir primero los tests, si no que implica una fase de refactorización que nos ayuda a eliminar todo código repetitivo o innecesario.</li><li><strong>Documentación</strong>. Para hacer los tests primero tenemos que tener muy claro las funcionalidades que queremos desarrollar, y es necesario tener una buena definición de requisitos y casos de uso, y los propios tests se convierte en una buena documentación de nuestro código.</li><li><strong>Escalabilidad</strong>. Al partir de los tests, el código final implementado tiene mucha más facilidad para que sea desarrollado cumpliendo ciertas reglas de <code>clean architecture</code>, lo cual va a proporcionar que nuestro código sea fácilmente escalable.</li></ul><h1>Casos prácticos.</h1><p>Vamos a ver cómo se puede hacer esta práctica en Swift, y para ello vamos a partir del <a href="https://github.com/alfonsomiranda/Testing-in-swift/tree/basic">código</a> que usamos previamente para conocer los tests.</p><p>Empezamos por algo muy simple, aprovechando el código que ya tenemos. En el <code>ViewController</code> vamos a necesitar un método que nos concatene dos cadenas para los dos textfields que hay en la pantalla. Imaginad que no lo habíamos resuelto en el método <code>composeFullNameAction</code>, si no que lo haremos en otro método. Este método tendría como parámetros de entrada dos cadenas y devolvería otro <code>String</code>. En el <code>ViewController</code> creamos un método con esta definición pero sin ninguna implementación (solo devolviendo una cadena vacía para que no falle).</p><pre><code><span class="keyword">func</span> concatenate(first: <span class="type">String</span>, second: <span class="type">String</span>) -&gt; <span class="type">String</span> {
    <span class="keyword">return</span> <span class="string">""</span>
}
</code></pre><p>Ahora nos vamos al target de tests y añadimos un nuevo tests. Este test debe de comprobar si el método <code>concatenate</code> al pasarle dos cadenas devuelve la concatenación de ambas con la primera letra en mayúscula.</p><pre><code><span class="keyword">func</span> test_concatenate_two_strings() {
    <span class="keyword">let</span> viewController = <span class="type">ViewController</span>()
    
    <span class="call">XCTAssertEqual</span>(viewController.<span class="call">concatenate</span>(first: <span class="string">"alfonso"</span>, second: <span class="string">"miranda"</span>), <span class="string">"Alfonso Miranda"</span>)
}
</code></pre><p>Si ejecutamos este test obtenemos un error, obviamente, al no estar la implementación hecha. Esta fase de TDD se la conoce como <code>red</code>, fase roja donde estamos pensando qué queremos desarrollar y definiéndolo.</p><img src="https://alfonsomiranda.com/images/tdd/tddRedState.png" alt="TDD Red state" width="800"/><p>En este momento tenemos que ir a la implementación y darle una solución para que nuestro test pase. Nuestro método quedaría como sigue.</p><pre><code><span class="keyword">func</span> concatenate(first: <span class="type">String</span>, second: <span class="type">String</span>) -&gt; <span class="type">String</span> {
    <span class="keyword">return</span> first.<span class="property">capitalized</span> + <span class="string">" "</span> + second.<span class="property">capitalized</span>
}
</code></pre><p>Y si ahora compilamos los tests vemos que lo pasa. Esta fase se la conoce como fase <code>green</code>, que consiste en, sea como sea, que nuestros tests pasen y estén en verde.</p><img src="https://alfonsomiranda.com/images/tdd/tddGreenState.png" alt="TDD Green state" width="800"/><p>Este "sea como sea" lo digo porque en esta fase no es necesario que nuestro código sea perfecto, simplemente que cumpla nuestros requisitos. En TDD hay una tercera fase, que es la de refactorizar. Una vez pasado el test y tenerlo en verde, tenemos que hacer el código lo más limpio posible. En nuestro caso, al ser tan simple no es necesario refactorizar, pero en casos más complejos no vamos a escribir el código bien a la primera, e incluso TDD nos recomienda primero solucionar la implementación y después hacer todas las correcciones necesarias.</p><p>Podemos ver este ciclo en esta gráfica.</p><img src="https://alfonsomiranda.com/images/tdd/test-driven-development.png" alt="TDD States" width="800"/><p>Aunque me gusta más esta imagen de <a href="https://quii.gitbook.io/learn-go-with-tests/">Denise</a>, mucho más descriptiva.</p><img src="https://alfonsomiranda.com/images/tdd/red-green-blue-gophers-smaller.png" alt="TDD Gophers" width="800"/><p>La filosofía de TDD es básicamente estos tres estados y lo podemos aplicar a cualquier funcionalidad de nuestra aplicación.</p><p>Podemos verlo con un ejemplo más complejo, y de camino vemos como hacer testing con nuestra arquitectura limpia donde nos comunicamos desacoplando las capas a base de protocolos.</p><p>Si recordamos, en el proyecto teníamos un provider en el que habíamos implementado un método que nos obtenía una película de un endpoint que habíamos definido. Ahora vamos a necesitar obtener un listado de películas que nos proporciona otro endpoint, así que la funcionalidad que queremos desarrollar es un método que nos devuelva un array de <code>MovieEntity</code>. En MovieProvider definimos un nuevo método tal que así:</p><pre><code><span class="keyword">func</span> getMovies(success: <span class="keyword">@escaping</span>([<span class="type">MovieEntity</span>]) -&gt; <span class="type">Void</span>, failure: <span class="keyword">@escaping</span>(<span class="type">EError</span>) -&gt; <span class="type">Void</span>) {
    
}
</code></pre><p>Nos vamos a nuestra clase de tests y añadimos uno nuevo que cumpla los requisitos que nos hemos impuesto. Para ello vemos que nos falta poder mockear el BaseProvider ya que, como vimos en el artículo anterior, todo lo que sea "externo" a lo que queremos probar lo tenemos que falsear. Pero si vemos como es nuestro BaseProvider, nos falta añadirle un protocolo para poder mockearlo correctamente. Además, como veremos más adelante, va a perder el sentido de ser Base, y lo vamos a utilizar más como un componente (necesario para poder testear donde se usa), así que lo modificamos así.</p><pre><code><span class="keyword">protocol</span> ProviderProtocol {
    <span class="keyword">func</span> request&lt;T: <span class="type">Decodable</span>&gt;(entityClass: <span class="type">T</span>.<span class="type">Type</span>, endpoint: <span class="type">String</span>, method: <span class="type">HTTPMethod</span>, success: <span class="keyword">@escaping</span>(<span class="keyword">_</span> entity: <span class="type">T</span>) -&gt; <span class="type">Void</span>, failure: <span class="keyword">@escaping</span>(<span class="type">EError</span>) -&gt; <span class="type">Void</span>)
}


<span class="keyword">class</span> Provider: <span class="type">ProviderProtocol</span> {
    <span class="keyword">func</span> request&lt;T: <span class="type">Decodable</span>&gt;(entityClass: <span class="type">T</span>.<span class="type">Type</span>, endpoint: <span class="type">String</span>, method: <span class="type">HTTPMethod</span>, success: <span class="keyword">@escaping</span>(<span class="keyword">_</span> entity: <span class="type">T</span>) -&gt; <span class="type">Void</span>, failure: <span class="keyword">@escaping</span>(<span class="type">EError</span>) -&gt; <span class="type">Void</span>) {
        <span class="keyword">let</span> session = <span class="type">URLSession</span>(configuration: .<span class="dotAccess">default</span>, delegate: <span class="keyword">nil</span>, delegateQueue: .<span class="dotAccess">main</span>)
        <span class="keyword">let</span> url = <span class="type">URL</span>(string: endpoint)!
        <span class="keyword">let</span> task = session.<span class="call">dataTask</span>(with: url, completionHandler: { (data: <span class="type">Data</span>?, response: <span class="type">URLResponse</span>?, error: <span class="type">Error</span>?) -&gt; <span class="type">Void</span> <span class="keyword">in
            
            guard</span> error == <span class="keyword">nil else</span> {
                <span class="call">failure</span>(<span class="type">EError</span>(domain: endpoint, code: <span class="number">0</span>, localizedDescription: error?.<span class="property">localizedDescription</span> ?? <span class="string">""</span>))
                <span class="keyword">return</span>
            }
            <span class="keyword">guard let</span> responseData = data <span class="keyword">else</span> {
                <span class="call">failure</span>(<span class="type">EError</span>(domain: <span class="string">""</span>, code: -<span class="number">1</span>, localizedDescription: <span class="string">""</span>))
                <span class="keyword">return</span>
            }
            <span class="keyword">do</span> {
                <span class="keyword">if let</span> response = <span class="keyword">try</span>? <span class="type">JSONDecoder</span>().<span class="call">decode</span>(<span class="type">T</span>.<span class="keyword">self</span>, from: responseData) {
                    <span class="call">success</span>(response)
                } <span class="keyword">else</span> {
                    <span class="call">failure</span>(<span class="type">EError</span>(domain: <span class="string">""</span>, code: -<span class="number">1</span>, localizedDescription: <span class="string">""</span>))
                }
            }
        })
        task.<span class="call">resume</span>()
    }
}

</code></pre><p>Y modificamos nuestro MovieProvider de forma que podamos inyectarle ese Provider y no heredar de él, porque como comentáamos antes el testeo se hace muy complicado. El resultado sería el siguiente.</p><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">protocol</span> MovieProvider {
    <span class="keyword">func</span> getMovie(success: <span class="keyword">@escaping</span>(<span class="type">MovieEntity</span>) -&gt; <span class="type">Void</span>, failure: <span class="keyword">@escaping</span>(<span class="type">EError</span>) -&gt; <span class="type">Void</span>)
}

<span class="keyword">class</span> MovieProviderImplementation: <span class="type">MovieProvider</span> {
    
    <span class="keyword">var</span> provider: <span class="type">ProviderProtocol</span> = <span class="type">Provider</span>()
    
    <span class="keyword">func</span> getMovie(success: <span class="keyword">@escaping</span>(<span class="type">MovieEntity</span>) -&gt; <span class="type">Void</span>, failure: <span class="keyword">@escaping</span>(<span class="type">EError</span>) -&gt; <span class="type">Void</span>) {
        provider.<span class="call">request</span>(entityClass: <span class="type">MovieEntity</span>.<span class="keyword">self</span>, endpoint: <span class="string">"http://demo8628160.mockable.io/movie"</span>, method: .<span class="dotAccess">get</span>, success: { (entity) <span class="keyword">in</span>
            <span class="call">success</span>(entity)
        }) { (error) <span class="keyword">in</span>
            <span class="call">failure</span>(error)
        }
    }
    
    <span class="keyword">func</span> getMovies(success: <span class="keyword">@escaping</span>([<span class="type">MovieEntity</span>]) -&gt; <span class="type">Void</span>, failure: <span class="keyword">@escaping</span>(<span class="type">EError</span>) -&gt; <span class="type">Void</span>) {
        
    }
}
</code></pre><p>Ahora si podemos crearnos ese mock y quedaría de la siguiente forma.</p><pre><code><span class="keyword">import</span> Foundation
<span class="keyword">@testable import</span> TestingBasic

<span class="keyword">class</span> ProviderMock: <span class="type">ProviderProtocol</span> {
    <span class="keyword">var</span> isRequestCalled = <span class="keyword">false
    var</span> isSuccess = <span class="keyword">true
    
    func</span> request&lt;T&gt;(entityClass: <span class="type">T</span>.<span class="type">Type</span>, endpoint: <span class="type">String</span>, method: <span class="type">HTTPMethod</span>, success: <span class="keyword">@escaping</span> (<span class="type">T</span>) -&gt; <span class="type">Void</span>, failure: <span class="keyword">@escaping</span> (<span class="type">EError</span>) -&gt; <span class="type">Void</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Decodable</span> {
        <span class="keyword">self</span>.<span class="property">isRequestCalled</span> = <span class="keyword">true
        
        if</span> isSuccess {
            <span class="call">success</span>([<span class="type">MovieEntity</span>(title: <span class="string">"Terminator"</span>, year: <span class="string">"1985"</span>, movieEntityDescription: <span class="string">""</span>, director: <span class="string">""</span>), <span class="type">MovieEntity</span>(title: <span class="string">"Terminator"</span>, year: <span class="string">"1985"</span>, movieEntityDescription: <span class="string">""</span>, director: <span class="string">""</span>), <span class="type">MovieEntity</span>(title: <span class="string">"Terminator"</span>, year: <span class="string">"1985"</span>, movieEntityDescription: <span class="string">""</span>, director: <span class="string">""</span>), <span class="type">MovieEntity</span>(title: <span class="string">"Terminator"</span>, year: <span class="string">"1985"</span>, movieEntityDescription: <span class="string">""</span>, director: <span class="string">""</span>)] <span class="keyword">as</span>! <span class="type">T</span>)
        }
    }
}
</code></pre><p>Como todos los mocks, añado dos flags, uno para indicar que he pasado por el método y otro para controlar si quiero testear cuando todo ha ido bien o cuando ha habido error. Y en el caso de <code>success</code> devuelvo un array mockeado de MovieEntity.</p><p>Ahora nos vamos a hacer el test, y este tiene una peculiaridad y es que tenemos que probar bloques. Para ello tenemos que hacer uso de <code>expectation</code>, que nos simula una llamada en otro hilo para hacer la espera a que se ejecute ese bloque. Podemos verlo en este código.</p><pre><code><span class="keyword">func</span> test_movieProvider_get_movies_when_is_success() {
    <span class="comment">//GIVEN</span>
    <span class="keyword">let</span> provider = <span class="type">MovieProviderImplementation</span>()
    <span class="keyword">let</span> providerMock = <span class="type">ProviderMock</span>()
    providerMock.<span class="property">isSuccess</span> = <span class="keyword">true</span>
    provider.<span class="property">provider</span> = providerMock

    <span class="keyword">let</span> expect = <span class="keyword">self</span>.<span class="call">expectation</span>(description: <span class="keyword">#function</span>)
    
    <span class="comment">//WHEN</span>
    provider.<span class="call">getMovies</span> { (movies) <span class="keyword">in</span>
        <span class="call">XCTAssertEqual</span>(movies.<span class="property">count</span>, <span class="number">4</span>)
        expect.<span class="call">fulfill</span>()
    } failure: { (error) <span class="keyword">in</span>
        
    }
    
    <span class="call">waitForExpectations</span>(timeout: <span class="number">1.0</span>) { error <span class="keyword">in</span>
        <span class="call">XCTAssertNil</span>(error)
        <span class="call">XCTAssertTrue</span>(providerMock.<span class="property">isRequestCalled</span>)
    }
}
</code></pre><p>Estamos en primer lugar inicializando <code>MovieProvider e inyectándole nuestro mock, indicándole que vamos a testear el bloque de success. En el bloque tenemos que llamar a </code>expect.fulfill()<code> y fuera de él añadimos un </code>watiForExpectations` con un timeout. De esta forma podemos probar que ese bloque se ejecuta correctamente y que devuelve lo que esperamos.</p><p>Si ejecutamos los tests vemos que, tras el tiempo que hemos indicado en el timeout, nos da error, ya que obviamente en nuestra implementación aún no estamos haciendo nada. Estamos en la fase roja, así que vamos a hacer esa implementación para pasar a verde.</p><pre><code><span class="keyword">func</span> getMovies(success: <span class="keyword">@escaping</span>([<span class="type">MovieEntity</span>]) -&gt; <span class="type">Void</span>, failure: <span class="keyword">@escaping</span>(<span class="type">EError</span>) -&gt; <span class="type">Void</span>) {
    provider.<span class="call">request</span>(entityClass: [<span class="type">MovieEntity</span>].<span class="keyword">self</span>, endpoint: <span class="string">"http://demo8628160.mockable.io/movies"</span>, method: .<span class="dotAccess">get</span>) { (movies) <span class="keyword">in</span>
        <span class="call">success</span>(movies)
    } failure: { (error) <span class="keyword">in</span>
        <span class="call">failure</span>(error)
    }
}
</code></pre><p>Ya tenemos la implementación hecha, llamando a provider y devolviendo nuestro listado de MovieEntity. Si ahora ejecutamos los tests vemos que pasamos al estado verde y ya los pasamos.</p><p>A partir de aquí entraríamos en la parte de refactorización, mejorando el código, eliminando posibles duplicidades y probando el resultado con datos reales.</p><p>Tiene muchas ventajas trabajar según la metodología TDD como vimos al comienzo de este texto, y uno de los más valiosos es que cuando terminamos de desarrollar nuestra funcionalidad los tests ya están hechos, y no se nos "olvida" hacerlos.</p><p><a href="https://github.com/alfonsomiranda/Testing-in-swift/tree/tdd">Aquí</a> tenéis todo el código que hemos visto aquí por si quéreis trastear con él.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://alfonsomiranda.com/posts/tests-swift-basic-concepts</guid><title>Tests en swift: Conceptos básicos</title><description>En cualquier proyecto software es muy importante que nuestro código esté testeado. En este artículo vamos a ver los conceptos básicos para comenzar a hacer tests en swift, que necesitamos saber y por qué son tan necesarios añadirlos en nuestros proyectos.</description><link>https://alfonsomiranda.com/posts/tests-swift-basic-concepts</link><pubDate>Mon, 5 Apr 2021 14:24:00 +0200</pubDate><content:encoded><![CDATA[<p>En todo este artículo los tests a los que nos vamos a referir son los tests unitarios. ¿Y qué son los tests unitarios? Según la <a href="https://es.wikipedia.org/wiki/Prueba_unitaria">wikipedia</a>,</p><blockquote><p>una prueba unitaria es una forma de comprobar el correcto funcionamiento de una unidad de código es decir, desarrollar una serie de pruebas que comprueben el correcto funcionamiento de diferentes unidades de nuestro código implementado en nuestra aplicación.</p></blockquote><h1>¿Qué es un test y por qué lo necesito?</h1><p>En proyectos reales donde el tiempo siempre es escaso siempre se “olvidan” los tests aludiendo a que consumen tiempo de desarrollo y que no disponemos de él. Vamos a ver por qué son necesarios los tests:</p><h2>¡Porque nos ahorran tiempo!</h2><p>Si, la primera en la frente. Frente a las creencias de que nos consume mucho tiempo, la realidad es que es todo lo contrario. No solo el desarrollo de los tests es relativamente sencillo (si usamos una buena arquitectura, ya llegaremos a eso), si no que nos ahorra muchos problemas futuros, como malos funcionamientos, comportamientos no deseados, problemas colaterales a cambios en el código.</p><h2>Refactorización de código.</h2><p>Cuando uno se dispone a refactorizar un código por diferentes motivos (deuda técnica, cambios funcionales), y más si el código que estás modificando no es tuyo, siempre está el riesgo y el miedo a romper algo que no estamos teniendo en cuenta. Si todo ese código está testeado, el riesgo a tener problemas colaterales se reduce mucho (nunca podemos llegar a 0) y podemos cambiar este código con mucha más tranquilidad ya que los tests nos avisarán de que algo hemos roto y podremos controlarlo.</p><h2>Definición de los casos de uso.</h2><p>De algo que hablaremos en esta serie de artículos es de TDD que es, a MUY grandes rasgos, definir primero los tests y a partir de ellos desarrollar la implementación de nuestro proyecto. De esta forma, a partir de ir creando los tests podemos ir definiendo todos los casos de uso, y a partir de ellos definir todo el funcionamiento de la aplicación.</p><h2>Refinamiento del código.</h2><p>Si estamos construyendo tests de código ya implementado nos podemos dar cuenta en algún momento que nos resulta imposible testear alguna parte de nuestro código. ¿Es problema de que no sabemos hacer tests? No, seguramente es que el código está mal escrito y necesita ser mejorado. Esto nos ayuda a refactorizar este código y arreglarlo para que podamos desarrollar los tests, y de esta forma refinarlo y mejorarlo.</p><h2>Integración contínua.</h2><p>Si tenemos nuestro código en un sistema de integración continua, el tener implementado tests hará que no se suba código roto a entornos de desarrollo o producción, y que se controle que todo lo que debería funcionar, funcione. Hay muchas otras razones para usar tests, pero estas creo que son, en mi opinión, las más básicas.</p><h1>Conceptos básicos.</h1><p>Para añadir tests en tu proyecto se puede hacer o bien, si es un proyecto nuevo marcando que añade un target de test,</p><img src="https://alfonsomiranda.com/images/testBasics/createProject.png" alt="Crear nuevo proyecto con tests" width="800"/><p>o en tu proyecto ya creado añadiendo ese target y asociarlo al principal.</p><img src="https://alfonsomiranda.com/images/testBasics/addTestsProject.png" alt="Seleccionamos un nuevo target de tests unit" width="800"/><img src="https://alfonsomiranda.com/images/testBasics/addTestsProject2.png" alt="Ponemos su nombre y target" width="800"/><p>Una vez hecho esto, con CMD + U ejecutamos los tests y nos lista los que han pasado y los que no.</p><img src="https://alfonsomiranda.com/images/testBasics/firstTestsBuild.png" alt="Ponemos su nombre y target" width="800"/><p>Ahora vamos a hacer nuestro primer test. Para ello vamos a añadir en el ViewController creado por defecto una variable con un valor.</p><pre><code><span class="keyword">import</span> UIKit

<span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {
    
    <span class="keyword">let</span> titleLabel: <span class="type">UILabel</span> = {
      <span class="keyword">let</span> label = <span class="type">UILabel</span>()
      label.<span class="property">text</span> = <span class="string">"Welcome"</span>
      <span class="keyword">return</span> label
    }()

    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        
    }
}
</code></pre><p>Y añadimos un test para probarlo.</p><pre><code><span class="keyword">func</span> test_viewController_titleLabel_is_welcome() {
        <span class="keyword">let</span> viewController = <span class="type">ViewController</span>()
        
        <span class="call">XCTAssertEqual</span>(viewController.<span class="property">titleLabel</span>.<span class="property">text</span>!, <span class="string">"Welcome"</span>)
    }
</code></pre><p>Aquí lo único que hacemos es cargar el ViewController y comprobar que el texto que hay en el titleLabel es “Welcome”. Si ejecutamos <code>CMD + U</code> vemos que pasa el test sin problemas. Fácil, ¿no?</p><p>Seguimos y ahora añadimos en el Storyboard un label que enlazamos en el <code>ViewController</code> y en el viewDidLoad le asignamos un texto.</p><pre><code><span class="keyword">import</span> UIKit

<span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {
    
    <span class="keyword">let</span> titleLabel: <span class="type">UILabel</span> = {
      <span class="keyword">let</span> label = <span class="type">UILabel</span>()
      label.<span class="property">text</span> = <span class="string">"Welcome"</span>
      <span class="keyword">return</span> label
    }()
    
    <span class="keyword">@IBOutlet weak var</span> nameLabel: <span class="type">UILabel</span>!

    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        
        <span class="keyword">self</span>.<span class="property">nameLabel</span>.<span class="property">text</span> = <span class="string">"Alfonso"</span>
    }
}
</code></pre><p>Ahora vamos a hacer su test. Si lo hacemos igual que antes veremos que no es que falle el test, es que nos da un crash. Esto es porque tenemos que cargar el ViewController a partir del Storyboard para que el nameLabel no sea nil, así que lo hacemos y comprobamos el texto igual que haciamos en el ejemplo anterior.</p><pre><code><span class="keyword">func</span> test_viewController_nameLabel_is_Alfonso() {
        <span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="keyword">nil</span>)
        <span class="keyword">let</span> viewController = storyboard
            .<span class="call">instantiateViewController</span>(withIdentifier: <span class="string">"viewController"</span>) <span class="keyword">as</span>! <span class="type">ViewController</span>
        
        <span class="call">XCTAssertEqual</span>(viewController.<span class="property">nameLabel</span>.<span class="property">text</span>!, <span class="string">"Alfonso"</span>)
    }
</code></pre><p>Y si lo ejecutamos vemos que de nuevo nos da el mismo error, nameLabel nos sigue llegando nil. Nos falta que se ejecuten los eventos de un ViewController necesarios para que se cargue todo correctamente, y lo hacemos con beginAppearanceTransition de la siguiente forma:</p><pre><code><span class="keyword">func</span> test_viewController_nameLabel_is_Alfonso() {
        <span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="keyword">nil</span>)
        <span class="keyword">let</span> viewController = storyboard
            .<span class="call">instantiateViewController</span>(withIdentifier: <span class="string">"viewController"</span>) <span class="keyword">as</span>! <span class="type">ViewController</span>
        viewController.<span class="call">beginAppearanceTransition</span>(<span class="keyword">true</span>, animated: <span class="keyword">false</span>)
        <span class="call">XCTAssertEqual</span>(viewController.<span class="property">nameLabel</span>.<span class="property">text</span>!, <span class="string">"Alfonso"</span>)
        viewController.<span class="call">endAppearanceTransition</span>()
    }
</code></pre><p>Y ahora si que todo funciona correctamente y pasamos el test. El ejemplo es muy simple, pero si en algún momento se toca ese label y se cambia, el test fallará y así evitará que se cometa ese error, porque o bien se ha cambiado el label de manera equivocada o hay que actualizar el test para que asuma un nuevo funcionamiento.</p><p>Lo complicamos un poquito más, y añadimos dos textFields y un botón en nuestro ViewController. La idea es que en uno de los textField se escriba el nombre y en el otro el apellido, y que al darle al botón en el label se formatee correctamente poniendo el nombre, un espacio, y el apellido. El ViewController quedaría así.</p><pre><code><span class="keyword">import</span> UIKit

<span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {
    
    <span class="keyword">let</span> titleLabel: <span class="type">UILabel</span> = {
      <span class="keyword">let</span> label = <span class="type">UILabel</span>()
      label.<span class="property">text</span> = <span class="string">"Welcome"</span>
      <span class="keyword">return</span> label
    }()
    
    <span class="keyword">@IBOutlet weak var</span> nameLabel: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet weak var</span> composeButton: <span class="type">UIButton</span>!
    <span class="keyword">@IBOutlet weak var</span> nameTextField: <span class="type">UITextField</span>!
    <span class="keyword">@IBOutlet weak var</span> lastNmeTextField: <span class="type">UITextField</span>!

    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        
        <span class="keyword">self</span>.<span class="property">nameLabel</span>.<span class="property">text</span> = <span class="string">"Alfonso"</span>
    }
    
    <span class="keyword">@IBAction func</span> composeFullNameAction() {
        <span class="keyword">if let</span> name = nameTextField.<span class="property">text</span>, <span class="keyword">let</span> lastName = lastNmeTextField.<span class="property">text</span> {
            <span class="keyword">self</span>.<span class="property">nameLabel</span>.<span class="property">text</span> = <span class="string">"</span>\(name) \(lastName)<span class="string">"</span>
        }
    }
}
</code></pre><p>Ahora tenemos que probar que tras pulsarse el botón el resultado en el label es el que nosotros esperamos, así que añadimos este test.</p><pre><code><span class="keyword">func</span> test_viewController_compose_name_label() {
        <span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="keyword">nil</span>)
        <span class="keyword">let</span> viewController = storyboard
            .<span class="call">instantiateViewController</span>(withIdentifier: <span class="string">"viewController"</span>) <span class="keyword">as</span>! <span class="type">ViewController</span>
        
        viewController.<span class="call">beginAppearanceTransition</span>(<span class="keyword">true</span>, animated: <span class="keyword">false</span>)
        viewController.<span class="property">nameTextField</span>.<span class="property">text</span> = <span class="string">"alfonso"</span>
        viewController.<span class="property">lastNmeTextField</span>.<span class="property">text</span> = <span class="string">"miranda"</span>
        viewController.<span class="property">composeButton</span>.<span class="call">sendActions</span>(for: .<span class="dotAccess">touchUpInside</span>)
        <span class="call">XCTAssertEqual</span>(<span class="string">"alfonso miranda"</span>, viewController.<span class="property">nameLabel</span>.<span class="property">text</span>!)
        viewController.<span class="call">endAppearanceTransition</span>()
    }
</code></pre><p>Podemos ver que mediante el método sendActions del botón simulamos el touch en ese botón y podemos comprobar que el resultado es el deseado.</p><p>Aquí podemos probar lo que hablábamos antes. Como vemos, en el ejemplo he puesto tanto el nombre y el apellido empezando en minúscula (es un error pensado). Imaginad que en nuestra aplicación, aunque el usuario lo ponga empezando por minúscula lo formateamos y ponemos la primera letra en mayúsculas. Si hacemos ese cambio en el código y ejecutamos ese test, fallará. En este caso el comportamiento ha cambiado y tenemos que arreglar el test asegurando que en vez de lo anteriormente escrito ahora sea</p><pre><code><span class="call">XCTAssertEqual</span>(<span class="string">"Alfonso Miranda"</span>, viewController.<span class="property">nameLabel</span>.<span class="property">text</span>!)
</code></pre><h1>Los pasos para un test: given, when, then.</h1><p>Hay una práctica llamada given, when, then, definido por Martin Fowler que se usa para hacer más ordenados y legibles los tests. Se trata de dividir en tres partes un test:</p><ul><li>Given: Correspondería con la preparación del test, cargarlo en el estado inicial, lo que en un caso de uso serían las pre-condiciones.</li><li>When: Se añaden las condiciones en las que queremos hacer el test.</li><li>Then: Se realiza el test y se obtienen los resultados.</li></ul><p>Swift no es una excepción, y podemos usar el último ejemplo del punto anterior para explicarlo. Given es la parte que prepara el test y carga lo que necesitamos, en este caso sería</p><pre><code><span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="keyword">nil</span>)
<span class="keyword">let</span> viewController = storyboard.<span class="call">instantiateViewController</span>(withIdentifier: <span class="string">"viewController"</span>) <span class="keyword">as</span>! <span class="type">ViewController</span>
</code></pre><p>When sería:</p><pre><code>viewController.<span class="property">nameTextField</span>.<span class="property">text</span> = <span class="string">"alfonso"</span>
viewController.<span class="property">lastNmeTextField</span>.<span class="property">text</span> = <span class="string">"miranda"</span>
viewController.<span class="property">composeButton</span>.<span class="call">sendActions</span>(for: .<span class="dotAccess">touchUpInside</span>)
</code></pre><p>Y Then:</p><pre><code><span class="call">XCTAssertEqual</span>(<span class="string">"Alfonso Miranda"</span>, viewController.<span class="property">nameLabel</span>.<span class="property">text</span>!)
</code></pre><h1>Mocks: qué son y cómo usarlos.</h1><p>Por último en esta introducción al maravilloso mundo de los tests vamos a hablar de los mocks, aunque esto lo veremos más detenidamente en el siguiente artículo donde hablaremos de testing con VIPER.</p><p>Cuando queremos testear una parte de nuestro código, una capa o una vista, podemos estar haciendo ahí uso de elementos que no son el objetivo de probarlo estos tests que estamos haciendo, si no que son una herramienta que usamos pero que deberían tener sus propios tests sin interferir en los de este trozo de código.</p><p>Un ejemplo sería cuando testeamos una vista que recibe una serie de datos para pintarlos en ella, de un servicio por ejemplo. Para testear esa vista no tenemos que probar que los servicios funcionan, si no que cuando se reciban los datos lo pintamos en el sitio correcto.</p><p>Vamos a hacer un ejemplo con este caso de uso en concreto. Imaginaros que tenemos un provider que consume un api rest que nos devuelve una película, con su descripción, su director y su año. Nos creamos el provider y un modelo para lo que nos devuelve la api y lo llamamos desde la vista. La llamada será desde un botón y lo pintaremos en un par de labels que añadimos en el storyboard y en el viewController. Vamos a dar por supuesto que tenemos el provider y el modelo hecho donde implementaremos un protocolo (al final del artículo pondré un enlace al proyecto completo).</p><p>Nuestro ViewController quedaría de la siguiente forma:</p><pre><code><span class="keyword">import</span> UIKit

<span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {
    
    <span class="keyword">let</span> titleLabel: <span class="type">UILabel</span> = {
      <span class="keyword">let</span> label = <span class="type">UILabel</span>()
      label.<span class="property">text</span> = <span class="string">"Welcome"</span>
      <span class="keyword">return</span> label
    }()
    
    <span class="keyword">var</span> movieProvider: <span class="type">MovieProvider</span> = <span class="type">MovieProviderImplementation</span>()
    
    <span class="keyword">@IBOutlet weak var</span> nameLabel: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet weak var</span> composeButton: <span class="type">UIButton</span>!
    <span class="keyword">@IBOutlet weak var</span> nameTextField: <span class="type">UITextField</span>!
    <span class="keyword">@IBOutlet weak var</span> lastNmeTextField: <span class="type">UITextField</span>!
    <span class="keyword">@IBOutlet weak var</span> titleMovieLabel: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet weak var</span> descriptionMovieLabel: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet weak var</span> getMovieButton: <span class="type">UIButton</span>!

    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        
        <span class="keyword">self</span>.<span class="property">nameLabel</span>.<span class="property">text</span> = <span class="string">"Alfonso"</span>
    }
    
    <span class="keyword">@IBAction func</span> composeFullNameAction() {
        <span class="keyword">if let</span> name = nameTextField.<span class="property">text</span>, <span class="keyword">let</span> lastName = lastNmeTextField.<span class="property">text</span> {
            <span class="keyword">self</span>.<span class="property">nameLabel</span>.<span class="property">text</span> = <span class="string">"</span>\(name.<span class="property">capitalized</span>) \(lastName.<span class="property">capitalized</span>)<span class="string">"</span>
        }
    }
    
    <span class="keyword">@IBAction func</span> getBestMovie() {
        movieProvider.<span class="call">getMovie</span>(success: { (movie) <span class="keyword">in
            self</span>.<span class="property">titleMovieLabel</span>.<span class="property">text</span> = movie.<span class="property">title</span>
            <span class="keyword">self</span>.<span class="property">descriptionMovieLabel</span>.<span class="property">text</span> = movie.<span class="property">movieEntityDescription</span>
        }) { (error) <span class="keyword">in</span>
            <span class="call">debugPrint</span>(<span class="string">"Error"</span>)
        }
    }
}
</code></pre><p>Como vemos es lo descrito anteriormente, al pulsar el botón esperamos la respuesta, y cuando la tenemos rellenamos esos dos labels. Hemos creado una acción para ello y hemos además añadido un IBOutlet para el botón, que nos hará falta para realizar los tests.</p><p>Nuestro provider, llamado MovieProvider, implementa a este protocolo:</p><pre><code><span class="keyword">protocol</span> MovieProvider {
    <span class="keyword">func</span> getMovie(success: <span class="keyword">@escaping</span>(<span class="type">MovieEntity</span>) -&gt; <span class="type">Void</span>, failure: <span class="keyword">@escaping</span>(<span class="type">EError</span>) -&gt; <span class="type">Void</span>)
}
</code></pre><p>Y nos ponemos a testear esto pero, ¿cómo lo hacemos?</p><p>Lo primero que pensaríamos en hacer una llamada real al servicio y testearlo pero esto tiene un problema: si el servicio falla, nuestros tests fallan, y sería engañoso ya que nuestro código está bien, lo que no está funcionando son los servicios y no es nuestra responsabilidad.</p><p>Así que vamos a hacer un mock de este provider en primer lugar:</p><pre><code><span class="keyword">import</span> Foundation
<span class="keyword">@testable import</span> TestingBasic

<span class="keyword">class</span> MovieProviderMock: <span class="type">MovieProvider</span> {
    <span class="keyword">var</span> isGetMovieCalled = <span class="keyword">false
    var</span> successState = <span class="keyword">false
    
    func</span> getMovie(success: <span class="keyword">@escaping</span> (<span class="type">MovieEntity</span>) -&gt; <span class="type">Void</span>, failure: <span class="keyword">@escaping</span> (<span class="type">EError</span>) -&gt; <span class="type">Void</span>) {
        <span class="keyword">self</span>.<span class="property">isGetMovieCalled</span> = <span class="keyword">true
        
        if</span> successState {
            <span class="keyword">let</span> entity = <span class="type">MovieEntity</span>(title: <span class="string">"Terminator 2"</span>, year: <span class="string">"1992"</span>, movieEntityDescription: <span class="string">"Un robot malo intentando matar a un niño"</span>, director: <span class="string">"Steven Spilberg"</span>)
            <span class="call">success</span>(entity)
        }
    }
}
</code></pre><p>Lo que estamos haciendo es hacer una implementación mockeada de nuestro provider. Tengo por costumbre, en primer lugar, tener un flag que me indique que ha ejecutado el método o no, para después en los tests comprobarlo. Además he añadido otro flag para indicar si quiero probar cuando ha ido todo bien o cuando ha habido un error, aunque en este caso solo he puesto salida para cuando todo ha ido correctamente.</p><p>En este caso me creo un MovieEntity (nuestro modelo) y lo devuelvo en el bloque de success.</p><p>Y con esto ya podemos crearnos nuestro test para comprobar qué pasa cuando le damos al botón de obtener la película, que sería de la siguiente forma:</p><pre><code><span class="keyword">func</span> test_viewController_get_movie_when_is_success() {
        <span class="comment">//GIVEN</span>
        <span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="keyword">nil</span>)
        <span class="keyword">let</span> viewController = storyboard
            .<span class="call">instantiateViewController</span>(withIdentifier: <span class="string">"viewController"</span>) <span class="keyword">as</span>! <span class="type">ViewController</span>
        viewController.<span class="call">beginAppearanceTransition</span>(<span class="keyword">true</span>, animated: <span class="keyword">false</span>)
        <span class="comment">//WHEN</span>
        <span class="keyword">let</span> provider = <span class="type">MovieProviderMock</span>()
        provider.<span class="property">successState</span> = <span class="keyword">true</span>
        viewController.<span class="property">movieProvider</span> = provider
        viewController.<span class="property">getMovieButton</span>.<span class="call">sendActions</span>(for: .<span class="dotAccess">touchUpInside</span>)
        <span class="comment">//THEN</span>
        <span class="call">XCTAssert</span>(provider.<span class="property">isGetMovieCalled</span>)
        <span class="call">XCTAssert</span>(viewController.<span class="property">titleMovieLabel</span>.<span class="property">text</span> == <span class="string">"Terminator 2"</span>)
        viewController.<span class="call">endAppearanceTransition</span>()
    }
</code></pre><p>Como podemos ver, el principio es similar a los anteriores tests, preparando en el GIVEN el test. En el WHEN inyectamos nuestro provider mockeado y “pulsamos” el botón de obtener la película. Y por último hacemos dos comprobaciones: que el método “GetMovie” ha sido llamado y que la respuesta se ha pintado en los labels correctos y con la información que esperábamos.</p><p>Es muy sencillo, en resumen todos los tests son similares a estos y en el siguiente artículo, usando VIPER como arquitectura, podremos profundizar más en estos conceptos.</p><p>Os dejo <a href="https://github.com/alfonsomiranda/Testing-in-swift/tree/basic/TestingBasic/TestingBasic">aquí</a> todo el código del proyecto.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://alfonsomiranda.com/posts/remote-work-with-your-team</guid><title>Trabajar con tu equipo en remoto</title><description>Hace unos días os comenté mis razones para trabajar en remoto. Para trabajar de esta forma es bueno que tanto tú como tu equipo sigáis unas buenas prácticas. He recopilado algunas que creo importantes y que algunas ya estoy aplicando en mi día a día y otras quiero ir añadiéndolas. Estas buenas prácticas no solo son necesarias si cada integrante del equipo está en su casa, si no cuando trabajamos con compañeros en otras oficinas, o incluso zonas separadas en la misma empresa.</description><link>https://alfonsomiranda.com/posts/remote-work-with-your-team</link><pubDate>Thu, 22 Mar 2018 14:24:00 +0100</pubDate><content:encoded><![CDATA[<p>Hace unos días os comenté mis <a href="https://alfonsomiranda.com/posts/why-working-in-remote/">razones para trabajar en remoto</a>. Para trabajar de esta forma es bueno que tanto tú como tu equipo sigáis unas buenas prácticas. He recopilado algunas que creo importantes y que algunas ya estoy aplicando en mi día a día y otras quiero ir añadiéndolas. Estas buenas prácticas no solo son necesarias si cada integrante del equipo está en su casa, si no cuando trabajamos con compañeros en otras oficinas, o incluso zonas separadas en la misma empresa.</p><h1>Comunicación.</h1><p>Hay que tener un buen canal de comunicación y saberlo usar. Si hay conversaciones o información entre personas que estén físicamente juntas hay que informar a los que estén en remoto. Es importante que haya este canal, pero hay que tener cuidado de que haya demasiados y diferentes canales que sean usados de manera irresponsable, transmitiendo un mensaje importante por un canal por donde solo se debería mensajes más superfluos. De esta forma el mensaje se puede perder y no tener claro por donde transmitirlo y por donde escucharlo. Y otra cosa importante relacionada con la comunicación es entender que debe de ser lo más asíncrona posible y que solo en momentos necesarios se necesite una respuesta rápida o una charla más profunda e inmediata.</p><h1>Update para sincronizarnos.</h1><p>Al estar separados físicamente es importante tener una pequeña reunión de 10–15 minutos al principio de la jornada para que todos los integrantes del equipo sepan en qué punto están, en que van a trabajar y que problemas y necesidades tienen. Esto no solo sirve para evitar confusiones o duplicidades en las tareas, si no que nos ayuda a hacer más equipo, a no aislarnos y sentirnos unidos en el trabajo que tenemos que realizar.</p><h1>Informa de tu status.</h1><p>Es importante que todo el equipo sepa en que estado estás, si estás trabajando en ese momento, si te has ido a comer, si tienes cita con el médico o has ido al gimnasio. De esta forma tu equipo sabrá si puede contar con tu ayuda o estás ausente. No hay que tener ningún problema en decir que haces, todos debemos ser responsables de nuestro trabajo y confiar en que todos estamos haciendo las tareas que nos corresponde.</p><h1>Utiliza la tecnología.</h1><p>Como ya vimos en el artículo anterior una de las excusas para no trabajar en remoto eran fácilmente solucionables con la tecnología. Antes era mucho más complicado trabajar en remoto porque la tecnología no acompañaba, las conexiones a internet eran lentas y no había las herramientas adecuadas. Hoy en día tenemos de todo a nuestro alcance para organizar el trabajo del equipo (jira, confluence, trello, basecamp), tener reuniones donde vernos las caras, compartir nuestro código, nuestra pantalla (skype, webex, appear.in) y para compartir archivos o documentos (dropbox, drive).</p><h1>Trabajo sincronizado, trabajo asíncrono.</h1><p>Una de las partes más importantes es evitar bloqueos en nuestro trabajo y en el de nuestros compañeros, así que hace falta tener una planificación clara del trabajo que tenemos que realizar en cada jornada antes de empezar (de ahí la importancia del daily). A veces, ni con esta planificación se puede evitar que haya algún bloqueo, así que es bastante recomendable coincidir al menos cuatro horas todo el equipo, y el resto de la jornada que cada uno elija el momento en el que sea más productivo.</p><h1>Compartir nuestro trabajo.</h1><p>Al no vernos las caras a diario es importante que hable nuestro trabajo y que nuestros compañeros estén informados de lo que hacemos y nos valoren por ello. Tenemos que hacer notar nuestra presencia de la mejor forma, comentar los commits de nuestros compañeros, hacer code reviews e incluso de vez en cuando hacer pair programming para solucionar algún problema complejo y aprender y mejorar de forma contínua.</p><h1>La fuente de agua.</h1><p>Algo de lo que ya he hablado en algún punto anterior de forma directa o indirecta es la importancia de hacer equipo. Una idea bastante buena que encontré en el libro Remote es tener una “fuente de agua”. Cuando estamos en la oficina muchas veces vamos a la fuente del agua/máquina de café/cocina y nos encontramos a algún compañero con el que tenemos una charla informal de cualquier tema, del partido del fútbol del fin de semana, de tus hijos (los padres somos muy pesados con este tema) o de las ganas que tienes de unas vacaciones. Esto lo podemos hacer en remoto creando un grupo/chat donde poder compartir cosas más superfluas con nuestros compañeros y sobre todo usarlo. Enviar el último gif gracioso, comentar la noticia del día, cualquier tema es bueno para cuando queramos despejar un poco la mente del trabajo diario.</p><h1>Team buildings.</h1><p>Pese a trabajar en remoto a veces nos gusta tener contacto humano con nuestros compañeros y es algo que puede ayudar a mejorar las capacidades del equipo. Y es importante hacer de estas reuniones algo especial y que a todo el mundo le apetezca y le atraiga. Por supuesto, esto no debe ser algo impuesto y obligatorio ya que lo convertiría en una reunión más, y no es necesario que sea algo espectacular como un viaje al Caribe o ir a hacer parapente, con tomar unas cervezas y unas tapas todos juntos es más que suficiente. Seguro que hay muchas más prácticas que se me escapan o que tendría mejorar, ¿cuales son las tuyas?</p>]]></content:encoded></item><item><guid isPermaLink="true">https://alfonsomiranda.com/posts/why-working-in-remote</guid><title>¿Por qué trabajo en remoto?</title><description>Desde hace algunos meses ha cambiado mi forma de trabajar, de la forma clásica de ir a diario a la oficina y quedarme algún día en remoto (o el típico “¡los miércoles teletrabajo!”) a quedarme trabajando en remoto e ir a la oficina en casos muy puntuales y necesarios. Es lo llamado remote first y cada vez es una práctica más extendida en ciertos ámbitos como puede ser el desarrollo de software gracias a los avances de la tecnología y la facilidad que tenemos para desarrollar nuestro trabajo en cualquier sitio con las únicas herramientas de un portátil y una conexión a internet.</description><link>https://alfonsomiranda.com/posts/why-working-in-remote</link><pubDate>Fri, 26 Jan 2018 14:24:00 +0100</pubDate><content:encoded><![CDATA[<p>Desde hace algunos meses ha cambiado mi forma de trabajar, de la forma clásica de ir a diario a la oficina y quedarme algún día en remoto (o el típico “¡los miércoles teletrabajo!”) a quedarme trabajando en remoto e ir a la oficina en casos muy puntuales y necesarios. Es lo llamado remote first y cada vez es una práctica más extendida en ciertos ámbitos como puede ser el desarrollo de software gracias a los avances de la tecnología y la facilidad que tenemos para desarrollar nuestro trabajo en cualquier sitio con las únicas herramientas de un portátil y una conexión a internet.</p><p>Soy muy defensor de esta práctica y recientemente me he terminado un buen libro sobre este tema llamado <a href="https://www.amazon.es/Remote-Required-David-Heinemeier-Hansson/dp/0091954673/">Remote</a>, escrito por los cofundadores de <a href="http://37signals.com/">37signals.com</a>. Es una empresa donde todos sus trabajadores están en remoto (total o parcialmente), y pese a que este libro está escrito en el año 2014 es aún más válido hoy en día. Muchas de las ideas que exponen son cosas que ya rondaban por la cabeza y que ponía en práctica, pero reconforta mucho ver que uno no está loco por pensar de esta forma y que funciona en el mundo real.</p><p>Quiero comentaros algunos miedos que puede haber con esta forma de trabajar, las ventajas que conlleva y las buenas prácticas necesarias para que todo salga lo mejor posible. Gracias a este libro he podido poner mis ideas en orden y aquí quiero contaros desde mi perspectiva como poder llevarlo a cabo.</p><h1>Mis razones</h1><p>Lo primero que tenemos que preguntarnos es qué razones habría para trabajar en remoto. A nivel personal tenía éstas:</p><ul><li><strong>Ahorrar tiempo en desplazamientos.</strong> Me ponía muy nervioso tirarme una hora metido en mi coche, rodeado de otros muchos coches con gente cabreada, todos saliendo a la misma hora de camino a los mismos sitios, para llegar a la oficina, sentarme en mi sitio con una silla que no se adapta a mis problemas de espalda, sacar mi macbook de la mochila para conectarlo a un monitor más pequeño de lo que me gustaría y conectarme a una conexión a internet similar a la que tengo en casa. Ese viaje en coche (o en transporte público), además de la perdida de tiempo, conlleva mucho estrés y empezar mal el día. Trabajando en remoto puedo utilizar este tiempo para trabajar, teniendo la oportunidad de desayunar sin las prisas de salir antes de que el atasco sea aún mayor, teniendo el tiempo suficiente para ducharte y prepararte con tranquilidad (luego veremos que es importante no trabajar en pijama, al menos en mi opinión) y, en definitiva, empezar el día con ganas y no con desesperación.</li><li><strong>Interrupciones everywhere.</strong> Seguro que conocéis a mucha gente que intenta llegar antes que nadie a la oficina para tener una o dos horas en solitario y avanzar lo máximo posible (yo solía hacer esto), o se quedan cuando ya se han ido todos por la misma razón. En la oficina suele haber mil interrupciones, muchas de ellas innecesarias, con la excusa de que ya que te tienen al lado pueden “asaltarte” en cualquier momento. Suelen surgir las reuniones por cualquier razón, tu jefe puede venir varias veces para que le expliques como va tu trabajo (ese trabajo que no te está dejando hacer), aviso de tus compañeros para ir a desayunar justo en el momento que más productivo estás siendo y mucho más. Cuando estás en remoto las reuniones conllevan más preparación técnica y no es tan fácil como ir a tu sitio y meterte en una sala, con lo que muchas de esos encuentros se cambiarán por un mail o un mensaje, ya que realmente no eran tan importante como para hacer perder una hora a unos pocos de trabajadores. En casa nadie te molesta si tú no quieres, puedes ser eficiente y elegir cuando estás abierto a interrupciones.</li><li><strong>Conciliación familiar.</strong> Seguro que este concepto lo hemos escuchado mil veces, la famosa y necesaria conciliación familiar que muchas empresas lo arreglan dando un margen de entrada y otro de salida. Ésta es una de las razones más importantes para mi para trabajar en remoto, sobre todo desde que soy padre. El lujo de llevar a mi hijo al colegio por la mañana, de recogerle por la tarde, de estar disponible si tiene cualquier problema, si se pone malo, si hay que llevarlo al médico, de estar en su vida a diario y no solo verle unos minutos antes de que se vaya a dormir, todo eso es algo que tiene un valor incalculable y que, sin perder nada de eficiencia en mi trabajo, puedo hacer ahora sin problemas. Y muchas cosas más, si tengo médico no afecta tampoco a mi trabajo, cualquier gestión que solo se puede hacer por la mañana tampoco conlleva ausentarme de la oficina durante un tiempo o mil situaciones más que se nos puede ocurrir.</li><li><strong>Autogestión de mi tiempo.</strong> Este punto es casi un resumen de los puntos anteriores. Al trabajar en remoto no me tengo que ceñir a un horario estricto de oficina. Como hemos visto antes no tengo que coger mi coche y meterme en un atasco a las 7 de la mañana, si no que puedo empezar a trabajar cuando mi rendimiento sea mayor. En mi caso, de hecho, es incluso más temprano cuando me siento más productivo. Otros quizás sean más productivos por la noche, y de esta forma lo pueden aprovechar sin problemas. Esta gestión del tiempo nos permite esa conciliación familiar que veíamos en el punto anterior, el poder ir a hacer deporte o al gimnasio para estar un poco más en forma, el poder cocinar y comer más sano y tener una mayor calidad de vida sin que nuestro trabajo se vea perjudicado. Es importante saber trabajar de forma asíncrona con tus compañeros, pero siempre es recomendable coincidir un número de horas con ellos para evitar cualquier bloqueo.</li></ul><h1>¿Qué excusas existen para pensar que es una mala idea?</h1><p>No todo el mundo está de acuerdo con esta práctica y siempre surgirán mil excusas para afirmar que no se puede trabajar de esta forma, ya sea la empresa para la que trabajes, tu jefe, tus compañeros e incluso tú mismo.</p><p>Algunas que he oído, leído e incluso me he planteado yo mismo son las siguientes:</p><ul><li><strong>Trabajo en equipo.</strong> Creemos que si no estamos juntos no somos un equipo, no funcionamos como un equipo y las ideas no surgirán como cuando estamos físicamente juntos. Pensar así es un error, con la tecnología que tenemos hoy en día estamos a un click de poder estar hablando y viendo al resto del equipo y estar continuamente comunicados por chat/email/mensajería. Con todas estas herramientas podemos incluso compartir nuestro escritorio para que todo el equipo vea lo que estamos viendo, no existiendo ninguna diferencia con estar sentados el uno al lado del otro. El equipo no lo hace estar en un mismo espacio físico si no las personas y la buena comunicación entre ellas.</li><li><strong>Si no le veo, ¿estará trabajando?</strong> Esto es lo que pueden pensar muchos jefes, tener miedo a que tus trabajadores no estén trabajando sin vigilancia, como si fueran niños pequeños cuando no está la profe en clase. Si algún jefe te niega el trabajo en remoto por esta causa es un buen indicativo para saber que no confía en ti y en tu trabajo y quizás es hora de plantearse un cambio. Si tienes duda de que alguien trabaje cuando no le miras es más un problema de la contratación de esa persona que del trabajo en remoto. Muchas veces los jefes tienen una sensación de pérdida de control con esta práctica, pero seguro que en cuanto vea que la eficiencia y la productividad crecen esa sensación desaparecerá.</li><li><strong>En casa hay muchas distracciones.</strong> En casa tenemos la televisión, la videoconsola, quizás una lavadora que poner, una chapuza que hacer. Muchas distracciones. Pero realmente nada de esto nos distraerá si estamos motivados con nuestro trabajo y sabemos separar los tiempos para cada cosa. Es importante tener tu espacio de trabajo, saber y ser consciente de que cuando estás en ese sitio estás trabajando y tener una buena organización de tus tareas, objetivos y tiempos. Además, como hemos visto en la oficina también tenemos distracciones y muchas de ellas no depende de nosotros para evitarlas.</li><li><strong>Si otros no lo hacen …</strong> Esta era una duda para hacerlo en mi actual trabajo. Por norma nadie tiene un trabajo en remoto, existe la posibilidad de trabajar algún día en casa (dependiendo del proyecto) pero no de forma prioritaria como estoy yo en este momento. Por ello me surgía la duda de si el resto de compañeros me mirarían mal o creerían que me estaban dando un privilegio especial. Todo lo contrario, al final todo es más natural de lo que parece, todos saben mi situación y el que habla es mi trabajo. Incluso si algún día existe la necesidad de ir por la oficina me consultan mi disponibilidad y me avisan con el tiempo suficiente. Si mis resultados son buenos ni a mis compañeros ni a mis jefes les importa desde donde lo estoy haciendo.</li></ul><h1>¡Ojo, cuidado!</h1><p>Existen verdaderos peligros cuando trabajamos en remoto, pero al contrario de lo que se pueda pensar no es no trabajar si no trabajar demasiado. Esto puede pasar por una serie de circunstancia que he ido viendo en este tiempo.</p><ul><li><strong>Crea una rutina.</strong> Todo el mundo piensa que trabajar en casa es equivalente a sentarse frente al ordenador en pijama mientras te quitas las legañas recién levantado. A alguien le funcionará esto, pero yo no lo recomiendo. Lo importante es crearse una rutina, levantarte, ducharte, vestirte, desayunar y ponerte a trabajar como si fueras a la oficina. Intentar hacerlo siempre en el mismo horario también ayudará ya que puedes correr el riesgo de estar todo el día trabajando, es decir, no delimitar ni cuando empiezas ni cuando acabas puede llevarte a ponerte a las 8 de la mañana y terminar a las 10 de la noche, quizás no de forma continuada. Yo también necesito tener mucha más organización que estando en la oficina, tener claras mis tareas y las horas de trabajo para no hacer ni más (te terminarás quemando) ni menos.</li><li><strong>Cuidado con aislarnos demasiado.</strong> El estar trabajando solo te puede llevar a aislarte y eso te termina encaminando a, de nuevo, trabajar demasiado, no hablar con nadie y quemarte. Es importante tener comunicación con tu equipo, y no solo para hablar de trabajo si no para tener alguna conversación superflua. También es necesario tener relaciones personales con amigos o familia. En este punto lo tengo fácil, tengo un hijo que tiene mil historias que contarme, así que tengo bastante cubierto el no aislarme nunca.</li><li><strong>Equilibrio entre trabajo y vida.</strong> Tiene mucha relación con los dos puntos anteriores, hay que saber tener un equilibrio entre tu lado profesional y personal. Si lo mezclas demasiado terminas perjudicando tu trabajo y tu vida personal. El apunte de vestirte y no trabajar en pijama para mi es muy importante. Puede ser que un día no salga en todo el día de casa por cualquier razón, pero estoy vestido con mi “ropa de trabajo” mientras dure mi jornada laboral, y me cambio (o bien me pongo el pijama o algo más cómodo) cuando termino. Lo mismo cuando estoy haciendo algo personal o de ocio con el ordenador, dicen que lo ideal es separar incluso el equipo, es decir, usar el macbook para trabajar y el iPad para ver webs o mirar cosas ajenas al trabajo. Hay muchos trucos y a cada uno les servirá uno diferente, pero es importante tener esto en cuenta.</li><li><strong>Elige bien tu lugar de trabajo.</strong> Ya que tú eliges donde trabajas, hazlo bien. Vas a pasar muchas horas sentado, píllate una buena silla que se adapte a tu cuerpo, una mesa a tu altura y un buen monitor. Puedes estar cómodo y crearte tu ambiente. Hay gente que como mejor trabaja es con total silencio, otros con música e incluso hay gente que con la tele de fondo. Estás solo, no molestarás a nadie, elige la opción que más te guste. Incluso si tu casa no está preparada o no estás cómodo te puedes buscar un lugar cerca de donde vives, un co-working o cualquier sitio con conexión a internet donde te sientas bien.</li><li><strong>Debes de estar siempre motivado.</strong> Alguna vez que he trabajado en remoto me he distraído mucho y lo he achacado a lo que hemos visto antes, en casa hay muchas distracciones. De vuelta a la oficina veía que me distraía igual y quizás el problema no era dónde trabajaba, si no cual era mi trabajo. No estaba motivado con ese proyecto, no estaba bien gestionado ni organizado y veía las tareas que tenía que hacer un sin sentido. Es importante estar motivado siempre y más en remoto, así que si te pasa eso o bien consigue cambiar lo que falla del proyecto o, si es imposible, cambia de proyecto.</li><li><strong>Que hable tu trabajo.</strong> Uno de los miedos que se tiene al estar en casa (sobre todo cuando el resto del equipo está en la oficina) es que no se valore tu trabajo y eso te impida avanzar y mejorar dentro de la estructura de la empresa. No tengáis miedo a ello, que hable tu trabajo, si es bueno se te valorará. Hay que ser muy proactivo para que nadie se olvide que tú estás en el equipo y conseguir que solo mirando tu trabajo la gente ya te tengan muy presente.</li><li><strong>Vigila esos kilos.</strong> Precisamente esto me está pasando. Yo pensaba que iba a disponer de más tiempo para poder hacer ejercicio y comer mejor. Es algo que tengo que cambiar ya que no lo he conseguido, he terminado no sacando tiempo para estas dos tareas y no sabiendo gestionar el tiempo para que entren en mi día a día. Cuando vas a la oficina al menos te tienes que mover un poco pero estando en casa el movimiento de tu cuerpo tiende a cero. Hay que esforzarse más, sal a andar o correr, apúntate al gimnasio o queda para jugar algún partidito. Y dedícale tiempo a cocinar, tu cuerpo te lo agradecerá.</li></ul><p>Creo que saber trabajar en remoto es muy útil incluso si no trabajas así, intentar limitar las reuniones, tener una mejor comunicación y organización y ser capaz de trabajar de forma asíncrona teniendo la menor dependencia posible con tus compañeros. Tengo la intención de crearme un “manual de estilo” para llevar las mejores prácticas de esta forma de trabajar y compartirlo con mis compañeros y de paso compartirlo por aquí por si a alguien le sirve de utilidad.</p><p>P.D.: Escribiendo este texto me encuentro con un <a href="https://medium.com/@devsdna/3-a%C3%B1os-trabajando-en-remoto-5ce27518ce36">artículo</a> de una empresa española, <a href="http://www.devsdna.com/">Devsdna</a>, que trabaja en remoto y que comparte su experiencia trabajando en remoto durante 3 años, donde destaca dos cosas que he querido reflejar yo también aquí: confianza y felicidad.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://alfonsomiranda.com/posts/clean-architecture-ios-viper</guid><title>Clean architecture en iOS: VIPER</title><description>En los últimos tiempos está muy de moda en el mundo del software la filosofía “clean”, hacer de la construcción de software un arte, y que estemos orgullosos del código que escribimos. Seguramente el mayor defensor de esta filosofía, o al menos el que más ha escrito al respecto sea Robert C. Martin, más conocido como Uncle Bob, y en este texto me basaré en mucho de lo que él ha escrito y contado. También hay que hacer alguna referencia a otros autores, como el conocido Gangs of four, los cuales escribieron mucho sobre patrones de diseño o Martin Fawler, el cual colaboró con Robert C. Martin en la definición de SOLID (que veremos más adelante) y escribió un libro imprescindible llamado Refactoring.</description><link>https://alfonsomiranda.com/posts/clean-architecture-ios-viper</link><pubDate>Fri, 20 Jan 2017 14:24:00 +0100</pubDate><content:encoded><![CDATA[<p>En los últimos tiempos está muy de moda en el mundo del software la filosofía “clean”, hacer de la construcción de software un arte, y que estemos orgullosos del código que escribimos.</p><p>Seguramente el mayor defensor de esta filosofía, o al menos el que más ha escrito al respecto sea <a href="https://en.wikipedia.org/wiki/Robert_Cecil_Martin">Robert C. Martin</a>, más conocido como Uncle Bob, y en este texto me basaré en mucho de lo que él ha escrito y contado. También hay que hacer alguna referencia a otros autores, como el conocido Gangs of four, los cuales escribieron mucho sobre patrones de diseño o <a href="https://es.wikipedia.org/wiki/Martin_Fowler">Martin Fawler</a>, el cual colaboró con Robert C. Martin en la definición de SOLID (que veremos más adelante) y escribió un libro imprescindible llamado <a href="https://www.amazon.es/Refactoring-Improving-Design-Existing-Technology/dp/0201485672/ref=sr_1_1?ie=UTF8&qid=1484827579&sr=8-1&keywords=refactoring">Refactoring</a>.</p><h1>Clean architecture.</h1><p>Robert C. Martin fue el que definió esta arquitectura allá por el año 2012 en su <a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html">web</a>. Existían entonces, y siguen existiendo, muchas arquitecturas definidas que intentan solucionar los mismos problemas:</p><ul><li><strong>Independiente de frameworks.</strong> Debemos hacer la arquitectura independiente de cualquier librería que usemos en el desarrollo, y que no nos aten a sus requisitos, usándolas como lo que son, herramientas para conseguir un fin concreto.</li><li><strong>Testeable.</strong> La lógica de negocio se debería poder testear sin necesidad de la interfaz de usuario (UI), base de datos, servidor web u otras herramientas externas, y de esta forma eliminar elementos que son más complicados de probar.</li><li><strong>Independiente de la UI.</strong> Como la interfaz de usuario suele ser el elemento que más expuesto está al cambio debemos asegurarnos que no afecten al resto del desarrollo. De esta forma, además, se podrá usar un mismo código para diferentes interfaces solo cambiando la capa de UI.</li><li><strong>Independiente de la base de datos.</strong> De forma similar al punto anterior, al ser la arquitectura independiente de la base de datos, o más genéricamente, de la fuente de datos, podemos hacer cambios en esta parte sin que afecte a la lógica de negocio, teniendo la posibilidad de cambiar una api por un webservice, una base de datos por una api, o cualquier combinación que se nos ocurra.</li><li><strong>Independiente de factores externos.</strong> Como resumen al resto de puntos, la lógica de negocio debe ser ajena a todo lo que venga del mundo exterior, pudiendo cambiar el resto de piezas sin que le afecte, como si de un puzzle se tratara.</li></ul><p>Como hemos comentado, las arquitecturas existententes solucionaban la mayoría de estos puntos y todas separaban la arquitectura en capas para diferenciar los diferentes conceptos, pero algunas estaban más enfocadas a la interfaz y otras a la lógica de negocio.</p><p>En el caso concreto de iOS, la más usada era (y es) MVC, aunque habitualmente esas siglas perdían su significado de “Model View Controller”, para pasar a ser “Massive View Controller”, al terminar siendo cualquier clase u objeto una vista, modelo y controlador a la vez, terminando por desvirtualizar e incluso elimininar la arquitectura.</p><img src="https://alfonsomiranda.com/images/cleanArchitecture/cleanArchitectureDiagraman.png" alt="The Clean Architecture, by Uncle Bob" width="800"/><p>En este diagrama se intentó unificar todas estas ideas en una sola, que fuera entendible y que cumpliera una serie de reglas.</p><h2>Reglas de dependencia.</h2><p>Los diferentes círculos representan diferentes capas del software. En general, cuanto mas nos alejemos del núcleo mayor es el nivel del software y más unido al framework está. Los círculos exteriores son mecanismos mientras que los interiores son políticas. La regla primordial que hace que esta arquitectura funcione es la regla de dependencia. Esta regla dice que las dependencias a nivel de código fuente sólo pueden apuntar hacia dentro. Nada que se encuentre en un circulo interior puede saber algo sobre lo que hay en un círculo exterior, es decir, algo declarado en un círculo externo no puede ser mencionado desde el código situado en un círculo interno. Eso incluye funciones, clases, variables o cualquier otra entidad software. Por la misma razón, los formatos de datos usados en un círculo exterior no deberían usarse por un círculo interior, especialmente si esos formatos son generados por algún framework en un círculo situado al exterior. No queremos que nada de un círculo exterior impacte en los círculos o niveles interiores.</p><h2>Entities</h2><p>Las entidades son usadas por la lógica de negocio de la aplicación, por los llamados interactors. Deben ser objetos que solo dependan de esta capa y que no deben ser usados por las capas superiores, teniendo éstas que funcionar con objetos más simples (diccionarios, arrays, struts, …) o con parámetros de una función.</p><h2>User Cases</h2><p>En esta capa, también llamada Interactor, se tienen los casos de uso, lo cual tienen que ser independiente de la fuente de datos o de la visualización de los mismos. Si cambia los datos no debe influir en estos casos de uso, al igual que si la apariencia de nuestro desarrollo cambia. Es donde tendremos la lógica de negocio en nuestra aplicación</p><h2>Interface adapters</h2><p>O también llamados Presenters, es la capa que comunica los resultados de los casos de uso con la capa más externa. Esta capa recogerá los datos del interactor que a su vez los habrá procesado de la fuente de datos, y los formateará para ser presentado en la capa más externa, ya sea en una UI, en una base de datos o en algún dispositivo.</p><h2>Frameworks y adapters</h2><p>Es la capa más externa y la más pegada a la tecnología que estamos usando. En una web sería el html/javascript, en una app iOS todo lo referente a UIKit. Esta capa es una de las que está más sujeta a cambios, y la que podemos hacer más intercambiable. Si nos enfocamos en iOS, solo (o casi) cambiando esta capa podremos adaptar nuestra aplicación a iPhone, iPad o Apple TV.</p><h2>Cruzando los límites, ¿cómo y qué puede cruzarlos?</h2><p>La forma en la que debemos comunicarnos entre capa sería a través de interfaces, protocolos o delegados. Debe ser lo más polimórfico posible y que no cause mucho daño el cambio de una de las capas, siempre respetando la interfaz. Si jugamos con protocolos haremos estas comunicaciones totalmente independiente las unas de las otras, y serán piezas fácilmente intercambiables. Desde la llegada de swift ha proliferado la llamada OPP (Programación orientada a protocolos), la cual, entre otras muchas cosas, ayuda mucho a este cometido.</p><h1>SOLID</h1><p>Antes de hablar de VIPER me gustaría comentar algo sobre <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design">SOLID</a>). Para el que aún no lo conozca, <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design">SOLID</a>) es una serie de principios básicos definidos por varios autores para el desarrollo orientado a objetos, unificados en este acrónimo inventado por nuestro Uncle Bob. Vamos a echarle un vistazo rápido a cada uno de ellos.</p><ul><li><strong>S: Single responsibility principle:</strong> Una clase debería solo tener una responsabilidad, es decir, solo debería de tener una razón para cambiar. Dicho de otra forma, cuando una clase o función es usada para más de una cosa suele ser causa de estar haciendo algo mal. Esto parece algo muy lógico y básico, pero muchas veces no se cumplen y terminamos haciendo pequeñas tareas en funcionalidades ya existentes porque “nos pilla más a mano”, terminando por ser un problema a la larga cuando ese método lo queramos usar en otro sitio, teniendo que recordar que también sirve para más cosas. Por ejemplo, si tenemos un método que imprime un documento, y en algún momento también añadimos ahí que se guarde en disco, si en otro lugar queremos imprimir tendríamos el problema de que también hará otras funciones no deseadas y que quizás ni recordemos que estaban ahí.</li><li><strong>O: Open/closed principle (Bertrand Meyer):</strong> Una clase debería ser abierta por extensión, pero nunca por modificación. Es decir, se puede heredar de esa clase, extenderla, pero nunca modificar su código fuente para adaptarla a todos los casos. La forma más fácil de extender una clase es con herencia o interfaces (protocolos en nuestro caso). Este principio puede parecer fácil pero no lo es tanto, ya que tenemos que tener bastante claro la definición de nuestro proyecto, y preveer que clases vamos a tener que extender, no siendo siempre posible y teniendo en algún momento que necesitar refactorizar.</li><li><strong>L: Liskov substitution principle (Barbara Liskov):</strong> Los objetos de un programa deberían de ser sustituidos por una subclase o instancia sin modificar el comportamiento del programa. Es decir, una clase que herede de otra no tiene que modificar el comportamiento de la clase base de tal forma que al sustituirlo por ella el comportamiento sea diferente. La forma más fácil de ver si estamos cumpliendo esta regla es sustituir en nuestro código la clase base por cualquiera de las subclases y ver si todo sigue funcionando igual.</li><li><strong>I: Interface segregation principle (Robert C. Martin):</strong> Muchos pequeños y específicos interfaces son mejores que uno genérico. Esto evita el acoplamiento y fomenta la segregación. Es parecido al primer principio pero orientado a interfaces, las cuales deben ser para un caso de uso concreto y no demasiado genérica. El objetivo de este principio es principalmente poder reaprovechar los interfaces en otras clases. Si tenemos un interface que compara y clona en el mismo interface, de manera más complicada se podrá utilizar en una clase que solo debe comparar o en otra que solo debe clonar.</li><li><strong>D: Dependency inversion principle (Robert C. Martin):</strong> Se debe depender de abstracciones, no de concreciones. Esto fomenta el uso de interfaces y es algo que ya hemos hablado antes en clean arquitecture, que debería ser la forma en la que se comunican las diferentes capas. De esta forma unas clases pueden interacturar con otras sin conocer toda su implementación, usando, por ejemplo, inyección de dependencias.</li></ul><h1>VIPER</h1><p>VIPER no es más que una implementación de esta arquitectura, orientada a un desarrollo iOS. VIPER es un conjunto de siglas que describen las diferentes capas, View, Interactor, Presenter, Entity y Routing.</p><img src="https://alfonsomiranda.com/images/cleanArchitecture/viperDiagraman.png" alt="VIPER" width="800"/><ul><li><strong>View:</strong> Capa que “pinta” lo que le mande el presenter y que, mediante los inputs del usuario le pregunta al presenter qué hacer. Esta capa tiene que ser totalmente pasiva, lo más “tonta” posible y tendrá dos formas de reaccionar: a los inputs externos (touch de un usuario, por ejemplo) o a órdenes del presenter.</li><li><strong>Interactor:</strong> Contiene la lógica de negocio de un caso de uso. Aquí se manipula las Entities (modelos) para una tarea específica. Como ya hemos dicho debe ser independiente de la interfaz gráfica y debe modelar lo recibido de una fuente de datos. Al hacerlo independiente de la interfaz este código debería ser compatible para desarrollar, por ejemplo, para iOS y OSX sin ningún problema.</li><li><strong>Presenter:</strong> Contiene la lógica que la vista tiene que presentar y reacciona a los inputs que desde la vista son mandadas. Esto quiere decir que le dirá a la UI que tiene que pintar al recibir la información del Interactor y reaccionará a las acciones de la View (UI) para hacer una navegación o pedir datos.</li><li><strong>Entity:</strong> Contiene el modelo de los objetos usados por el Interactor. Será, normalmente, un simple PONSO, o si estamos usando CoreData serán los NSManagedObjects generados.</li><li><strong>Routing:</strong> Contiene toda la navegación de la app. Es quizás la más complicada de entender al estar acostumbrados hasta ahora a hacer toda la navegación en los ViewController. Este Routing (también llamados Wireframe) son aprovechados para hacer la inyección de dependencias a la hora de crear una nueva navegación y presentar una nueva sección. Existen muchas formas de implementar esta parte y suele ser motivo de discusión de darle o no más responsabilidad. Lo importante es que en esta capa esté concentrado toda la navegación de la app.</li></ul><p>Esta separación cumple la <a href="http://www.objectmentor.com/resources/articles/srp.pdf">Single Responsibility Principle</a>. El Interactor es responsable de la lógica de negocio, el Presenter representa la interacción con el diseño y la View es responsable del diseño visual.</p><p>También es importante que cumpla la norma “Dependency segregation principle”, ya que a la hora de conectar las diferentes capas deberíamos hacerlo con interfaces, protocolos, y de esta forma depender de estas abstracciones y no de implementaciones concretas, pudiendo de esta forma cambiar la implementación de una capa sin que afecte a otras.</p><p>Los otros tres principios también deben ser cumplidos, en realidad cualquier arquitectura orientada a objetos debería cumplir SOLID, y aunque no sea fácil debemos obligarnos a ello.</p><p>Si en algún momento no estamos cumpliendo las diferentes buenas prácticas y normas no debemos tener miedo a refactorizar y siempre intentar mejorar el código. Si no sabéis qué es <a href="https://es.wikipedia.org/wiki/Teor%C3%ADa_de_las_ventanas_rotas">la teoría de las ventanas rotas</a> os invito a conocerla.</p><p>Para terminar, os dejo un poco de documentación y bibliografía en la que me he apoyado y basado para escribir esto:</p><ul><li>Clean arquitecture: <a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html">https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html</a></li><li>VIPER: <a href="https://www.objc.io/issues/13-architecture/viper/">https://www.objc.io/issues/13-architecture/viper/</a></li><li>SOLID: <a href="https://www.genbetadev.com/paradigmas-de-programacion/solid-cinco-principios-basicos-de-diseno-de-clases">https://www.genbetadev.com/paradigmas-de-programacion/solid-cinco-principios-basicos-de-diseno-de-clases</a></li><li>Clean Arquitecture by Robert C. Martin: <a href="https://www.amazon.es/Clean-Architecture-Robert-C-Martin/dp/0134494164/">https://www.amazon.es/Clean-Architecture-Robert-C-Martin/dp/0134494164/</a></li><li>Refactoring: <a href="https://www.amazon.es/Refactoring-Improving-Design-Existing-Technology/dp/0201485672/">https://www.amazon.es/Refactoring-Improving-Design-Existing-Technology/dp/0201485672/</a></li></ul>]]></content:encoded></item></channel></rss>