<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Alfonso Miranda</title><description>Mobile Software Engineer</description><link>http://alfonsomiranda.com</link><language>es</language><lastBuildDate>Mon, 12 Apr 2021 15:22:29 +0200</lastBuildDate><pubDate>Mon, 12 Apr 2021 15:22:29 +0200</pubDate><ttl>250</ttl><atom:link href="http://alfonsomiranda.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">http://alfonsomiranda.com/posts/2021-04-05-tests-basic</guid><title>Tests en swift: Conceptos básicos</title><description>En cualquier proyecto software es muy importante que nuestro código esté testeado. En este artículo vamos a ver los conceptos básicos para comenzar a hacer tests en swift, que necesitamos saber y por qué son tan necesarios añadirlos en nuestros proyectos.</description><link>http://alfonsomiranda.com/posts/2021-04-05-tests-basic</link><pubDate>Mon, 5 Apr 2021 14:24:00 +0200</pubDate><content:encoded><![CDATA[<p>En todo este artículo los tests a los que nos vamos a referir son los tests unitarios. ¿Y qué son los tests unitarios? Según la <a href="https://es.wikipedia.org/wiki/Prueba_unitaria">wikipedia</a>,</p><blockquote><p>una prueba unitaria es una forma de comprobar el correcto funcionamiento de una unidad de código es decir, desarrollar una serie de pruebas que comprueben el correcto funcionamiento de diferentes unidades de nuestro código implementado en nuestra aplicación.</p></blockquote><h1>¿Qué es un test y por qué lo necesito?</h1><p>En proyectos reales donde el tiempo siempre es escaso siempre se “olvidan” los tests aludiendo a que consumen tiempo de desarrollo y que no disponemos de él. Vamos a ver por qué son necesarios los tests:</p><h2>¡Porque nos ahorran tiempo!</h2><p>Si, la primera en la frente. Frente a las creencias de que nos consume mucho tiempo, la realidad es que es todo lo contrario. No solo el desarrollo de los tests es relativamente sencillo (si usamos una buena arquitectura, ya llegaremos a eso), si no que nos ahorra muchos problemas futuros, como malos funcionamientos, comportamientos no deseados, problemas colaterales a cambios en el código.</p><h2>Refactorización de código.</h2><p>Cuando uno se dispone a refactorizar un código por diferentes motivos (deuda técnica, cambios funcionales), y más si el código que estás modificando no es tuyo, siempre está el riesgo y el miedo a romper algo que no estamos teniendo en cuenta. Si todo ese código está testeado, el riesgo a tener problemas colaterales se reduce mucho (nunca podemos llegar a 0) y podemos cambiar este código con mucha más tranquilidad ya que los tests nos avisarán de que algo hemos roto y podremos controlarlo.</p><h2>Definición de los casos de uso.</h2><p>De algo que hablaremos en esta serie de artículos es de TDD que es, a MUY grandes rasgos, definir primero los tests y a partir de ellos desarrollar la implementación de nuestro proyecto. De esta forma, a partir de ir creando los tests podemos ir definiendo todos los casos de uso, y a partir de ellos definir todo el funcionamiento de la aplicación.</p><h2>Refinamiento del código.</h2><p>Si estamos construyendo tests de código ya implementado nos podemos dar cuenta en algún momento que nos resulta imposible testear alguna parte de nuestro código. ¿Es problema de que no sabemos hacer tests? No, seguramente es que el código está mal escrito y necesita ser mejorado. Esto nos ayuda a refactorizar este código y arreglarlo para que podamos desarrollar los tests, y de esta forma refinarlo y mejorarlo.</p><h2>Integración contínua.</h2><p>Si tenemos nuestro código en un sistema de integración continua, el tener implementado tests hará que no se suba código roto a entornos de desarrollo o producción, y que se controle que todo lo que debería funcionar, funcione. Hay muchas otras razones para usar tests, pero estas creo que son, en mi opinión, las más básicas.</p><h1>Conceptos básicos.</h1><p>Para añadir tests en tu proyecto se puede hacer o bien, si es un proyecto nuevo marcando que añade un target de test,</p><img src="http://alfonsomiranda.com/images/testBasics/createProject.png" alt="Crear nuevo proyecto con tests" width="800"/><p>o en tu proyecto ya creado añadiendo ese target y asociarlo al principal.</p><img src="http://alfonsomiranda.com/images/testBasics/addTestsProject.png" alt="Seleccionamos un nuevo target de tests unit" width="800"/><img src="http://alfonsomiranda.com/images/testBasics/addTestsProject2.png" alt="Ponemos su nombre y target" width="800"/><p>Una vez hecho esto, con CMD + U ejecutamos los tests y nos lista los que han pasado y los que no.</p><img src="http://alfonsomiranda.com/images/testBasics/firstTestsBuild.png" alt="Ponemos su nombre y target" width="800"/><p>Ahora vamos a hacer nuestro primer test. Para ello vamos a añadir en el ViewController creado por defecto una variable con un valor.</p><pre><code><span class="keyword">import</span> UIKit

<span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {
    
    <span class="keyword">let</span> titleLabel: <span class="type">UILabel</span> = {
      <span class="keyword">let</span> label = <span class="type">UILabel</span>()
      label.<span class="property">text</span> = <span class="string">"Welcome"</span>
      <span class="keyword">return</span> label
    }()

    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        
    }
}
</code></pre><p>Y añadimos un test para probarlo.</p><pre><code><span class="keyword">func</span> test_viewController_titleLabel_is_welcome() {
        <span class="keyword">let</span> viewController = <span class="type">ViewController</span>()
        
        <span class="call">XCTAssertEqual</span>(viewController.<span class="property">titleLabel</span>.<span class="property">text</span>!, <span class="string">"Welcome"</span>)
    }
</code></pre><p>Aquí lo único que hacemos es cargar el ViewController y comprobar que el texto que hay en el titleLabel es “Welcome”. Si ejecutamos <code>CMD + U</code> vemos que pasa el test sin problemas. Fácil, ¿no?</p><p>Seguimos y ahora añadimos en el Storyboard un label que enlazamos en el <code>ViewController</code> y en el viewDidLoad le asignamos un texto.</p><pre><code><span class="keyword">import</span> UIKit

<span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {
    
    <span class="keyword">let</span> titleLabel: <span class="type">UILabel</span> = {
      <span class="keyword">let</span> label = <span class="type">UILabel</span>()
      label.<span class="property">text</span> = <span class="string">"Welcome"</span>
      <span class="keyword">return</span> label
    }()
    
    <span class="keyword">@IBOutlet weak var</span> nameLabel: <span class="type">UILabel</span>!

    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        
        <span class="keyword">self</span>.<span class="property">nameLabel</span>.<span class="property">text</span> = <span class="string">"Alfonso"</span>
    }
}
</code></pre><p>Ahora vamos a hacer su test. Si lo hacemos igual que antes veremos que no es que falle el test, es que nos da un crash. Esto es porque tenemos que cargar el ViewController a partir del Storyboard para que el nameLabel no sea nil, así que lo hacemos y comprobamos el texto igual que haciamos en el ejemplo anterior.</p><pre><code><span class="keyword">func</span> test_viewController_nameLabel_is_Alfonso() {
        <span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="keyword">nil</span>)
        <span class="keyword">let</span> viewController = storyboard
            .<span class="call">instantiateViewController</span>(withIdentifier: <span class="string">"viewController"</span>) <span class="keyword">as</span>! <span class="type">ViewController</span>
        
        <span class="call">XCTAssertEqual</span>(viewController.<span class="property">nameLabel</span>.<span class="property">text</span>!, <span class="string">"Alfonso"</span>)
    }
</code></pre><p>Y si lo ejecutamos vemos que de nuevo nos da el mismo error, nameLabel nos sigue llegando nil. Nos falta que se ejecuten los eventos de un ViewController necesarios para que se cargue todo correctamente, y lo hacemos con beginAppearanceTransition de la siguiente forma:</p><pre><code><span class="keyword">func</span> test_viewController_nameLabel_is_Alfonso() {
        <span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="keyword">nil</span>)
        <span class="keyword">let</span> viewController = storyboard
            .<span class="call">instantiateViewController</span>(withIdentifier: <span class="string">"viewController"</span>) <span class="keyword">as</span>! <span class="type">ViewController</span>
        viewController.<span class="call">beginAppearanceTransition</span>(<span class="keyword">true</span>, animated: <span class="keyword">false</span>)
        <span class="call">XCTAssertEqual</span>(viewController.<span class="property">nameLabel</span>.<span class="property">text</span>!, <span class="string">"Alfonso"</span>)
        viewController.<span class="call">endAppearanceTransition</span>()
    }
</code></pre><p>Y ahora si que todo funciona correctamente y pasamos el test. El ejemplo es muy simple, pero si en algún momento se toca ese label y se cambia, el test fallará y así evitará que se cometa ese error, porque o bien se ha cambiado el label de manera equivocada o hay que actualizar el test para que asuma un nuevo funcionamiento.</p><p>Lo complicamos un poquito más, y añadimos dos textFields y un botón en nuestro ViewController. La idea es que en uno de los textField se escriba el nombre y en el otro el apellido, y que al darle al botón en el label se formatee correctamente poniendo el nombre, un espacio, y el apellido. El ViewController quedaría así.</p><pre><code><span class="keyword">import</span> UIKit

<span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {
    
    <span class="keyword">let</span> titleLabel: <span class="type">UILabel</span> = {
      <span class="keyword">let</span> label = <span class="type">UILabel</span>()
      label.<span class="property">text</span> = <span class="string">"Welcome"</span>
      <span class="keyword">return</span> label
    }()
    
    <span class="keyword">@IBOutlet weak var</span> nameLabel: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet weak var</span> composeButton: <span class="type">UIButton</span>!
    <span class="keyword">@IBOutlet weak var</span> nameTextField: <span class="type">UITextField</span>!
    <span class="keyword">@IBOutlet weak var</span> lastNmeTextField: <span class="type">UITextField</span>!

    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        
        <span class="keyword">self</span>.<span class="property">nameLabel</span>.<span class="property">text</span> = <span class="string">"Alfonso"</span>
    }
    
    <span class="keyword">@IBAction func</span> composeFullNameAction() {
        <span class="keyword">if let</span> name = nameTextField.<span class="property">text</span>, <span class="keyword">let</span> lastName = lastNmeTextField.<span class="property">text</span> {
            <span class="keyword">self</span>.<span class="property">nameLabel</span>.<span class="property">text</span> = <span class="string">"</span>\(name) \(lastName)<span class="string">"</span>
        }
    }
}
</code></pre><p>Ahora tenemos que probar que tras pulsarse el botón el resultado en el label es el que nosotros esperamos, así que añadimos este test.</p><pre><code><span class="keyword">func</span> test_viewController_compose_name_label() {
        <span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="keyword">nil</span>)
        <span class="keyword">let</span> viewController = storyboard
            .<span class="call">instantiateViewController</span>(withIdentifier: <span class="string">"viewController"</span>) <span class="keyword">as</span>! <span class="type">ViewController</span>
        
        viewController.<span class="call">beginAppearanceTransition</span>(<span class="keyword">true</span>, animated: <span class="keyword">false</span>)
        viewController.<span class="property">nameTextField</span>.<span class="property">text</span> = <span class="string">"alfonso"</span>
        viewController.<span class="property">lastNmeTextField</span>.<span class="property">text</span> = <span class="string">"miranda"</span>
        viewController.<span class="property">composeButton</span>.<span class="call">sendActions</span>(for: .<span class="dotAccess">touchUpInside</span>)
        <span class="call">XCTAssertEqual</span>(<span class="string">"alfonso miranda"</span>, viewController.<span class="property">nameLabel</span>.<span class="property">text</span>!)
        viewController.<span class="call">endAppearanceTransition</span>()
    }
</code></pre><p>Podemos ver que mediante el método sendActions del botón simulamos el touch en ese botón y podemos comprobar que el resultado es el deseado.</p><p>Aquí podemos probar lo que hablábamos antes. Como vemos, en el ejemplo he puesto tanto el nombre y el apellido empezando en minúscula (es un error pensado). Imaginad que en nuestra aplicación, aunque el usuario lo ponga empezando por minúscula lo formateamos y ponemos la primera letra en mayúsculas. Si hacemos ese cambio en el código y ejecutamos ese test, fallará. En este caso el comportamiento ha cambiado y tenemos que arreglar el test asegurando que en vez de lo anteriormente escrito ahora sea</p><pre><code><span class="call">XCTAssertEqual</span>(<span class="string">"Alfonso Miranda"</span>, viewController.<span class="property">nameLabel</span>.<span class="property">text</span>!)
</code></pre><h1>Los pasos para un test: given, when, then.</h1><p>Hay una práctica llamada given, when, then, definido por Martin Fowler que se usa para hacer más ordenados y legibles los tests. Se trata de dividir en tres partes un test:</p><ul><li>Given: Correspondería con la preparación del test, cargarlo en el estado inicial, lo que en un caso de uso serían las pre-condiciones.</li><li>When: Se añaden las condiciones en las que queremos hacer el test.</li><li>Then: Se realiza el test y se obtienen los resultados.</li></ul><p>Swift no es una excepción, y podemos usar el último ejemplo del punto anterior para explicarlo. Given es la parte que prepara el test y carga lo que necesitamos, en este caso sería</p><pre><code><span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="keyword">nil</span>)
<span class="keyword">let</span> viewController = storyboard.<span class="call">instantiateViewController</span>(withIdentifier: <span class="string">"viewController"</span>) <span class="keyword">as</span>! <span class="type">ViewController</span>
</code></pre><p>When sería:</p><pre><code>viewController.<span class="property">nameTextField</span>.<span class="property">text</span> = <span class="string">"alfonso"</span>
viewController.<span class="property">lastNmeTextField</span>.<span class="property">text</span> = <span class="string">"miranda"</span>
viewController.<span class="property">composeButton</span>.<span class="call">sendActions</span>(for: .<span class="dotAccess">touchUpInside</span>)
</code></pre><p>Y Then:</p><pre><code><span class="call">XCTAssertEqual</span>(<span class="string">"Alfonso Miranda"</span>, viewController.<span class="property">nameLabel</span>.<span class="property">text</span>!)
</code></pre><h1>Mocks: qué son y cómo usarlos.</h1><p>Por último en esta introducción al maravilloso mundo de los tests vamos a hablar de los mocks, aunque esto lo veremos más detenidamente en el siguiente artículo donde hablaremos de testing con VIPER.</p><p>Cuando queremos testear una parte de nuestro código, una capa o una vista, podemos estar haciendo ahí uso de elementos que no son el objetivo de probarlo estos tests que estamos haciendo, si no que son una herramienta que usamos pero que deberían tener sus propios tests sin interferir en los de este trozo de código.</p><p>Un ejemplo sería cuando testeamos una vista que recibe una serie de datos para pintarlos en ella, de un servicio por ejemplo. Para testear esa vista no tenemos que probar que los servicios funcionan, si no que cuando se reciban los datos lo pintamos en el sitio correcto.</p><p>Vamos a hacer un ejemplo con este caso de uso en concreto. Imaginaros que tenemos un provider que consume un api rest que nos devuelve una película, con su descripción, su director y su año. Nos creamos el provider y un modelo para lo que nos devuelve la api y lo llamamos desde la vista. La llamada será desde un botón y lo pintaremos en un par de labels que añadimos en el storyboard y en el viewController. Vamos a dar por supuesto que tenemos el provider y el modelo hecho donde implementaremos un protocolo (al final del artículo pondré un enlace al proyecto completo).</p><p>Nuestro ViewController quedaría de la siguiente forma:</p><pre><code><span class="keyword">import</span> UIKit

<span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {
    
    <span class="keyword">let</span> titleLabel: <span class="type">UILabel</span> = {
      <span class="keyword">let</span> label = <span class="type">UILabel</span>()
      label.<span class="property">text</span> = <span class="string">"Welcome"</span>
      <span class="keyword">return</span> label
    }()
    
    <span class="keyword">var</span> movieProvider: <span class="type">MovieProvider</span> = <span class="type">MovieProviderImplementation</span>()
    
    <span class="keyword">@IBOutlet weak var</span> nameLabel: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet weak var</span> composeButton: <span class="type">UIButton</span>!
    <span class="keyword">@IBOutlet weak var</span> nameTextField: <span class="type">UITextField</span>!
    <span class="keyword">@IBOutlet weak var</span> lastNmeTextField: <span class="type">UITextField</span>!
    <span class="keyword">@IBOutlet weak var</span> titleMovieLabel: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet weak var</span> descriptionMovieLabel: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet weak var</span> getMovieButton: <span class="type">UIButton</span>!

    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        
        <span class="keyword">self</span>.<span class="property">nameLabel</span>.<span class="property">text</span> = <span class="string">"Alfonso"</span>
    }
    
    <span class="keyword">@IBAction func</span> composeFullNameAction() {
        <span class="keyword">if let</span> name = nameTextField.<span class="property">text</span>, <span class="keyword">let</span> lastName = lastNmeTextField.<span class="property">text</span> {
            <span class="keyword">self</span>.<span class="property">nameLabel</span>.<span class="property">text</span> = <span class="string">"</span>\(name.<span class="property">capitalized</span>) \(lastName.<span class="property">capitalized</span>)<span class="string">"</span>
        }
    }
    
    <span class="keyword">@IBAction func</span> getBestMovie() {
        movieProvider.<span class="call">getMovie</span>(success: { (movie) <span class="keyword">in
            self</span>.<span class="property">titleMovieLabel</span>.<span class="property">text</span> = movie.<span class="property">title</span>
            <span class="keyword">self</span>.<span class="property">descriptionMovieLabel</span>.<span class="property">text</span> = movie.<span class="property">movieEntityDescription</span>
        }) { (error) <span class="keyword">in</span>
            <span class="call">debugPrint</span>(<span class="string">"Error"</span>)
        }
    }
}
</code></pre><p>Como vemos es lo descrito anteriormente, al pulsar el botón esperamos la respuesta, y cuando la tenemos rellenamos esos dos labels. Hemos creado una acción para ello y hemos además añadido un IBOutlet para el botón, que nos hará falta para realizar los tests.</p><p>Nuestro provider, llamado MovieProvider, implementa a este protocolo:</p><pre><code><span class="keyword">protocol</span> MovieProvider {
    <span class="keyword">func</span> getMovie(success: <span class="keyword">@escaping</span>(<span class="type">MovieEntity</span>) -&gt; <span class="type">Void</span>, failure: <span class="keyword">@escaping</span>(<span class="type">EError</span>) -&gt; <span class="type">Void</span>)
}
</code></pre><p>Y nos ponemos a testear esto pero, ¿cómo lo hacemos?</p><p>Lo primero que pensaríamos en hacer una llamada real al servicio y testearlo pero esto tiene un problema: si el servicio falla, nuestros tests fallan, y sería engañoso ya que nuestro código está bien, lo que no está funcionando son los servicios y no es nuestra responsabilidad.</p><p>Así que vamos a hacer un mock de este provider en primer lugar:</p><pre><code><span class="keyword">import</span> Foundation
<span class="keyword">@testable import</span> TestingBasic

<span class="keyword">class</span> MovieProviderMock: <span class="type">MovieProvider</span> {
    <span class="keyword">var</span> isGetMovieCalled = <span class="keyword">false
    var</span> successState = <span class="keyword">false
    
    func</span> getMovie(success: <span class="keyword">@escaping</span> (<span class="type">MovieEntity</span>) -&gt; <span class="type">Void</span>, failure: <span class="keyword">@escaping</span> (<span class="type">EError</span>) -&gt; <span class="type">Void</span>) {
        <span class="keyword">self</span>.<span class="property">isGetMovieCalled</span> = <span class="keyword">true
        
        if</span> successState {
            <span class="keyword">let</span> entity = <span class="type">MovieEntity</span>(title: <span class="string">"Terminator 2"</span>, year: <span class="string">"1992"</span>, movieEntityDescription: <span class="string">"Un robot malo intentando matar a un niño"</span>, director: <span class="string">"Steven Spilberg"</span>)
            <span class="call">success</span>(entity)
        }
    }
}
</code></pre><p>Lo que estamos haciendo es hacer una implementación mockeada de nuestro provider. Tengo por costumbre, en primer lugar, tener un flag que me indique que ha ejecutado el método o no, para después en los tests comprobarlo. Además he añadido otro flag para indicar si quiero probar cuando ha ido todo bien o cuando ha habido un error, aunque en este caso solo he puesto salida para cuando todo ha ido correctamente.</p><p>En este caso me creo un MovieEntity (nuestro modelo) y lo devuelvo en el bloque de success.</p><p>Y con esto ya podemos crearnos nuestro test para comprobar qué pasa cuando le damos al botón de obtener la película, que sería de la siguiente forma:</p><pre><code><span class="keyword">func</span> test_viewController_get_movie_when_is_success() {
        <span class="comment">//GIVEN</span>
        <span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="keyword">nil</span>)
        <span class="keyword">let</span> viewController = storyboard
            .<span class="call">instantiateViewController</span>(withIdentifier: <span class="string">"viewController"</span>) <span class="keyword">as</span>! <span class="type">ViewController</span>
        viewController.<span class="call">beginAppearanceTransition</span>(<span class="keyword">true</span>, animated: <span class="keyword">false</span>)
        <span class="comment">//WHEN</span>
        <span class="keyword">let</span> provider = <span class="type">MovieProviderMock</span>()
        provider.<span class="property">successState</span> = <span class="keyword">true</span>
        viewController.<span class="property">movieProvider</span> = provider
        viewController.<span class="property">getMovieButton</span>.<span class="call">sendActions</span>(for: .<span class="dotAccess">touchUpInside</span>)
        <span class="comment">//THEN</span>
        <span class="call">XCTAssert</span>(provider.<span class="property">isGetMovieCalled</span>)
        <span class="call">XCTAssert</span>(viewController.<span class="property">titleMovieLabel</span>.<span class="property">text</span> == <span class="string">"Terminator 2"</span>)
        viewController.<span class="call">endAppearanceTransition</span>()
    }
</code></pre><p>Como podemos ver, el principio es similar a los anteriores tests, preparando en el GIVEN el test. En el WHEN inyectamos nuestro provider mockeado y “pulsamos” el botón de obtener la película. Y por último hacemos dos comprobaciones: que el método “GetMovie” ha sido llamado y que la respuesta se ha pintado en los labels correctos y con la información que esperábamos.</p><p>Es muy sencillo, en resumen todos los tests son similares a estos y en el siguiente artículo, usando VIPER como arquitectura, podremos profundizar más en estos conceptos.</p><p>Os dejo <a href="https://github.com/alfonsomiranda/Testing-in-swift/tree/basic/TestingBasic/TestingBasic">aquí</a> todo el código del proyecto.</p>]]></content:encoded></item><item><guid isPermaLink="true">http://alfonsomiranda.com/posts/2018-03-22-remote-work-team</guid><title>Trabajar con tu equipo en remoto</title><description>Hace unos días os comenté mis razones para trabajar en remoto. Para trabajar de esta forma es bueno que tanto tú como tu equipo sigáis unas buenas prácticas. He recopilado algunas que creo importantes y que algunas ya estoy aplicando en mi día a día y otras quiero ir añadiéndolas. Estas buenas prácticas no solo son necesarias si cada integrante del equipo está en su casa, si no cuando trabajamos con compañeros en otras oficinas, o incluso zonas separadas en la misma empresa.</description><link>http://alfonsomiranda.com/posts/2018-03-22-remote-work-team</link><pubDate>Thu, 22 Mar 2018 14:24:00 +0100</pubDate><content:encoded><![CDATA[<p>Hace unos días os comenté mis <a href="https://alfonsomiranda.com/posts/2018-01-26-remote-work/">razones para trabajar en remoto</a>. Para trabajar de esta forma es bueno que tanto tú como tu equipo sigáis unas buenas prácticas. He recopilado algunas que creo importantes y que algunas ya estoy aplicando en mi día a día y otras quiero ir añadiéndolas. Estas buenas prácticas no solo son necesarias si cada integrante del equipo está en su casa, si no cuando trabajamos con compañeros en otras oficinas, o incluso zonas separadas en la misma empresa.</p><h1>Comunicación.</h1><p>Hay que tener un buen canal de comunicación y saberlo usar. Si hay conversaciones o información entre personas que estén físicamente juntas hay que informar a los que estén en remoto. Es importante que haya este canal, pero hay que tener cuidado de que haya demasiados y diferentes canales que sean usados de manera irresponsable, transmitiendo un mensaje importante por un canal por donde solo se debería mensajes más superfluos. De esta forma el mensaje se puede perder y no tener claro por donde transmitirlo y por donde escucharlo. Y otra cosa importante relacionada con la comunicación es entender que debe de ser lo más asíncrona posible y que solo en momentos necesarios se necesite una respuesta rápida o una charla más profunda e inmediata.</p><h1>Update para sincronizarnos.</h1><p>Al estar separados físicamente es importante tener una pequeña reunión de 10–15 minutos al principio de la jornada para que todos los integrantes del equipo sepan en qué punto están, en que van a trabajar y que problemas y necesidades tienen. Esto no solo sirve para evitar confusiones o duplicidades en las tareas, si no que nos ayuda a hacer más equipo, a no aislarnos y sentirnos unidos en el trabajo que tenemos que realizar.</p><h1>Informa de tu status.</h1><p>Es importante que todo el equipo sepa en que estado estás, si estás trabajando en ese momento, si te has ido a comer, si tienes cita con el médico o has ido al gimnasio. De esta forma tu equipo sabrá si puede contar con tu ayuda o estás ausente. No hay que tener ningún problema en decir que haces, todos debemos ser responsables de nuestro trabajo y confiar en que todos estamos haciendo las tareas que nos corresponde.</p><h1>Utiliza la tecnología.</h1><p>Como ya vimos en el artículo anterior una de las excusas para no trabajar en remoto eran fácilmente solucionables con la tecnología. Antes era mucho más complicado trabajar en remoto porque la tecnología no acompañaba, las conexiones a internet eran lentas y no había las herramientas adecuadas. Hoy en día tenemos de todo a nuestro alcance para organizar el trabajo del equipo (jira, confluence, trello, basecamp), tener reuniones donde vernos las caras, compartir nuestro código, nuestra pantalla (skype, webex, appear.in) y para compartir archivos o documentos (dropbox, drive).</p><h1>Trabajo sincronizado, trabajo asíncrono.</h1><p>Una de las partes más importantes es evitar bloqueos en nuestro trabajo y en el de nuestros compañeros, así que hace falta tener una planificación clara del trabajo que tenemos que realizar en cada jornada antes de empezar (de ahí la importancia del daily). A veces, ni con esta planificación se puede evitar que haya algún bloqueo, así que es bastante recomendable coincidir al menos cuatro horas todo el equipo, y el resto de la jornada que cada uno elija el momento en el que sea más productivo.</p><h1>Compartir nuestro trabajo.</h1><p>Al no vernos las caras a diario es importante que hable nuestro trabajo y que nuestros compañeros estén informados de lo que hacemos y nos valoren por ello. Tenemos que hacer notar nuestra presencia de la mejor forma, comentar los commits de nuestros compañeros, hacer code reviews e incluso de vez en cuando hacer pair programming para solucionar algún problema complejo y aprender y mejorar de forma contínua.</p><h1>La fuente de agua.</h1><p>Algo de lo que ya he hablado en algún punto anterior de forma directa o indirecta es la importancia de hacer equipo. Una idea bastante buena que encontré en el libro Remote es tener una “fuente de agua”. Cuando estamos en la oficina muchas veces vamos a la fuente del agua/máquina de café/cocina y nos encontramos a algún compañero con el que tenemos una charla informal de cualquier tema, del partido del fútbol del fin de semana, de tus hijos (los padres somos muy pesados con este tema) o de las ganas que tienes de unas vacaciones. Esto lo podemos hacer en remoto creando un grupo/chat donde poder compartir cosas más superfluas con nuestros compañeros y sobre todo usarlo. Enviar el último gif gracioso, comentar la noticia del día, cualquier tema es bueno para cuando queramos despejar un poco la mente del trabajo diario.</p><h1>Team buildings.</h1><p>Pese a trabajar en remoto a veces nos gusta tener contacto humano con nuestros compañeros y es algo que puede ayudar a mejorar las capacidades del equipo. Y es importante hacer de estas reuniones algo especial y que a todo el mundo le apetezca y le atraiga. Por supuesto, esto no debe ser algo impuesto y obligatorio ya que lo convertiría en una reunión más, y no es necesario que sea algo espectacular como un viaje al Caribe o ir a hacer parapente, con tomar unas cervezas y unas tapas todos juntos es más que suficiente. Seguro que hay muchas más prácticas que se me escapan o que tendría mejorar, ¿cuales son las tuyas?</p>]]></content:encoded></item><item><guid isPermaLink="true">http://alfonsomiranda.com/posts/2018-01-26-remote-work</guid><title>¿Por qué trabajo en remoto?</title><description>Desde hace algunos meses ha cambiado mi forma de trabajar, de la forma clásica de ir a diario a la oficina y quedarme algún día en remoto (o el típico “¡los miércoles teletrabajo!”) a quedarme trabajando en remoto e ir a la oficina en casos muy puntuales y necesarios. Es lo llamado remote first y cada vez es una práctica más extendida en ciertos ámbitos como puede ser el desarrollo de software gracias a los avances de la tecnología y la facilidad que tenemos para desarrollar nuestro trabajo en cualquier sitio con las únicas herramientas de un portátil y una conexión a internet.</description><link>http://alfonsomiranda.com/posts/2018-01-26-remote-work</link><pubDate>Fri, 26 Jan 2018 14:24:00 +0100</pubDate><content:encoded><![CDATA[<p>Desde hace algunos meses ha cambiado mi forma de trabajar, de la forma clásica de ir a diario a la oficina y quedarme algún día en remoto (o el típico “¡los miércoles teletrabajo!”) a quedarme trabajando en remoto e ir a la oficina en casos muy puntuales y necesarios. Es lo llamado remote first y cada vez es una práctica más extendida en ciertos ámbitos como puede ser el desarrollo de software gracias a los avances de la tecnología y la facilidad que tenemos para desarrollar nuestro trabajo en cualquier sitio con las únicas herramientas de un portátil y una conexión a internet.</p><p>Soy muy defensor de esta práctica y recientemente me he terminado un buen libro sobre este tema llamado <a href="https://www.amazon.es/Remote-Required-David-Heinemeier-Hansson/dp/0091954673/">Remote</a>, escrito por los cofundadores de <a href="http://37signals.com/">37signals.com</a>. Es una empresa donde todos sus trabajadores están en remoto (total o parcialmente), y pese a que este libro está escrito en el año 2014 es aún más válido hoy en día. Muchas de las ideas que exponen son cosas que ya rondaban por la cabeza y que ponía en práctica, pero reconforta mucho ver que uno no está loco por pensar de esta forma y que funciona en el mundo real.</p><p>Quiero comentaros algunos miedos que puede haber con esta forma de trabajar, las ventajas que conlleva y las buenas prácticas necesarias para que todo salga lo mejor posible. Gracias a este libro he podido poner mis ideas en orden y aquí quiero contaros desde mi perspectiva como poder llevarlo a cabo.</p><h1>Mis razones</h1><p>Lo primero que tenemos que preguntarnos es qué razones habría para trabajar en remoto. A nivel personal tenía éstas:</p><ul><li><strong>Ahorrar tiempo en desplazamientos.</strong> Me ponía muy nervioso tirarme una hora metido en mi coche, rodeado de otros muchos coches con gente cabreada, todos saliendo a la misma hora de camino a los mismos sitios, para llegar a la oficina, sentarme en mi sitio con una silla que no se adapta a mis problemas de espalda, sacar mi macbook de la mochila para conectarlo a un monitor más pequeño de lo que me gustaría y conectarme a una conexión a internet similar a la que tengo en casa. Ese viaje en coche (o en transporte público), además de la perdida de tiempo, conlleva mucho estrés y empezar mal el día. Trabajando en remoto puedo utilizar este tiempo para trabajar, teniendo la oportunidad de desayunar sin las prisas de salir antes de que el atasco sea aún mayor, teniendo el tiempo suficiente para ducharte y prepararte con tranquilidad (luego veremos que es importante no trabajar en pijama, al menos en mi opinión) y, en definitiva, empezar el día con ganas y no con desesperación.</li><li><strong>Interrupciones everywhere.</strong> Seguro que conocéis a mucha gente que intenta llegar antes que nadie a la oficina para tener una o dos horas en solitario y avanzar lo máximo posible (yo solía hacer esto), o se quedan cuando ya se han ido todos por la misma razón. En la oficina suele haber mil interrupciones, muchas de ellas innecesarias, con la excusa de que ya que te tienen al lado pueden “asaltarte” en cualquier momento. Suelen surgir las reuniones por cualquier razón, tu jefe puede venir varias veces para que le expliques como va tu trabajo (ese trabajo que no te está dejando hacer), aviso de tus compañeros para ir a desayunar justo en el momento que más productivo estás siendo y mucho más. Cuando estás en remoto las reuniones conllevan más preparación técnica y no es tan fácil como ir a tu sitio y meterte en una sala, con lo que muchas de esos encuentros se cambiarán por un mail o un mensaje, ya que realmente no eran tan importante como para hacer perder una hora a unos pocos de trabajadores. En casa nadie te molesta si tú no quieres, puedes ser eficiente y elegir cuando estás abierto a interrupciones.</li><li><strong>Conciliación familiar.</strong> Seguro que este concepto lo hemos escuchado mil veces, la famosa y necesaria conciliación familiar que muchas empresas lo arreglan dando un margen de entrada y otro de salida. Ésta es una de las razones más importantes para mi para trabajar en remoto, sobre todo desde que soy padre. El lujo de llevar a mi hijo al colegio por la mañana, de recogerle por la tarde, de estar disponible si tiene cualquier problema, si se pone malo, si hay que llevarlo al médico, de estar en su vida a diario y no solo verle unos minutos antes de que se vaya a dormir, todo eso es algo que tiene un valor incalculable y que, sin perder nada de eficiencia en mi trabajo, puedo hacer ahora sin problemas. Y muchas cosas más, si tengo médico no afecta tampoco a mi trabajo, cualquier gestión que solo se puede hacer por la mañana tampoco conlleva ausentarme de la oficina durante un tiempo o mil situaciones más que se nos puede ocurrir.</li><li><strong>Autogestión de mi tiempo.</strong> Este punto es casi un resumen de los puntos anteriores. Al trabajar en remoto no me tengo que ceñir a un horario estricto de oficina. Como hemos visto antes no tengo que coger mi coche y meterme en un atasco a las 7 de la mañana, si no que puedo empezar a trabajar cuando mi rendimiento sea mayor. En mi caso, de hecho, es incluso más temprano cuando me siento más productivo. Otros quizás sean más productivos por la noche, y de esta forma lo pueden aprovechar sin problemas. Esta gestión del tiempo nos permite esa conciliación familiar que veíamos en el punto anterior, el poder ir a hacer deporte o al gimnasio para estar un poco más en forma, el poder cocinar y comer más sano y tener una mayor calidad de vida sin que nuestro trabajo se vea perjudicado. Es importante saber trabajar de forma asíncrona con tus compañeros, pero siempre es recomendable coincidir un número de horas con ellos para evitar cualquier bloqueo.</li></ul><h1>¿Qué excusas existen para pensar que es una mala idea?</h1><p>No todo el mundo está de acuerdo con esta práctica y siempre surgirán mil excusas para afirmar que no se puede trabajar de esta forma, ya sea la empresa para la que trabajes, tu jefe, tus compañeros e incluso tú mismo.</p><p>Algunas que he oído, leído e incluso me he planteado yo mismo son las siguientes:</p><ul><li><strong>Trabajo en equipo.</strong> Creemos que si no estamos juntos no somos un equipo, no funcionamos como un equipo y las ideas no surgirán como cuando estamos físicamente juntos. Pensar así es un error, con la tecnología que tenemos hoy en día estamos a un click de poder estar hablando y viendo al resto del equipo y estar continuamente comunicados por chat/email/mensajería. Con todas estas herramientas podemos incluso compartir nuestro escritorio para que todo el equipo vea lo que estamos viendo, no existiendo ninguna diferencia con estar sentados el uno al lado del otro. El equipo no lo hace estar en un mismo espacio físico si no las personas y la buena comunicación entre ellas.</li><li><strong>Si no le veo, ¿estará trabajando?</strong> Esto es lo que pueden pensar muchos jefes, tener miedo a que tus trabajadores no estén trabajando sin vigilancia, como si fueran niños pequeños cuando no está la profe en clase. Si algún jefe te niega el trabajo en remoto por esta causa es un buen indicativo para saber que no confía en ti y en tu trabajo y quizás es hora de plantearse un cambio. Si tienes duda de que alguien trabaje cuando no le miras es más un problema de la contratación de esa persona que del trabajo en remoto. Muchas veces los jefes tienen una sensación de pérdida de control con esta práctica, pero seguro que en cuanto vea que la eficiencia y la productividad crecen esa sensación desaparecerá.</li><li><strong>En casa hay muchas distracciones.</strong> En casa tenemos la televisión, la videoconsola, quizás una lavadora que poner, una chapuza que hacer. Muchas distracciones. Pero realmente nada de esto nos distraerá si estamos motivados con nuestro trabajo y sabemos separar los tiempos para cada cosa. Es importante tener tu espacio de trabajo, saber y ser consciente de que cuando estás en ese sitio estás trabajando y tener una buena organización de tus tareas, objetivos y tiempos. Además, como hemos visto en la oficina también tenemos distracciones y muchas de ellas no depende de nosotros para evitarlas.</li><li><strong>Si otros no lo hacen …</strong> Esta era una duda para hacerlo en mi actual trabajo. Por norma nadie tiene un trabajo en remoto, existe la posibilidad de trabajar algún día en casa (dependiendo del proyecto) pero no de forma prioritaria como estoy yo en este momento. Por ello me surgía la duda de si el resto de compañeros me mirarían mal o creerían que me estaban dando un privilegio especial. Todo lo contrario, al final todo es más natural de lo que parece, todos saben mi situación y el que habla es mi trabajo. Incluso si algún día existe la necesidad de ir por la oficina me consultan mi disponibilidad y me avisan con el tiempo suficiente. Si mis resultados son buenos ni a mis compañeros ni a mis jefes les importa desde donde lo estoy haciendo.</li></ul><h1>¡Ojo, cuidado!</h1><p>Existen verdaderos peligros cuando trabajamos en remoto, pero al contrario de lo que se pueda pensar no es no trabajar si no trabajar demasiado. Esto puede pasar por una serie de circunstancia que he ido viendo en este tiempo.</p><ul><li><strong>Crea una rutina.</strong> Todo el mundo piensa que trabajar en casa es equivalente a sentarse frente al ordenador en pijama mientras te quitas las legañas recién levantado. A alguien le funcionará esto, pero yo no lo recomiendo. Lo importante es crearse una rutina, levantarte, ducharte, vestirte, desayunar y ponerte a trabajar como si fueras a la oficina. Intentar hacerlo siempre en el mismo horario también ayudará ya que puedes correr el riesgo de estar todo el día trabajando, es decir, no delimitar ni cuando empiezas ni cuando acabas puede llevarte a ponerte a las 8 de la mañana y terminar a las 10 de la noche, quizás no de forma continuada. Yo también necesito tener mucha más organización que estando en la oficina, tener claras mis tareas y las horas de trabajo para no hacer ni más (te terminarás quemando) ni menos.</li><li><strong>Cuidado con aislarnos demasiado.</strong> El estar trabajando solo te puede llevar a aislarte y eso te termina encaminando a, de nuevo, trabajar demasiado, no hablar con nadie y quemarte. Es importante tener comunicación con tu equipo, y no solo para hablar de trabajo si no para tener alguna conversación superflua. También es necesario tener relaciones personales con amigos o familia. En este punto lo tengo fácil, tengo un hijo que tiene mil historias que contarme, así que tengo bastante cubierto el no aislarme nunca.</li><li><strong>Equilibrio entre trabajo y vida.</strong> Tiene mucha relación con los dos puntos anteriores, hay que saber tener un equilibrio entre tu lado profesional y personal. Si lo mezclas demasiado terminas perjudicando tu trabajo y tu vida personal. El apunte de vestirte y no trabajar en pijama para mi es muy importante. Puede ser que un día no salga en todo el día de casa por cualquier razón, pero estoy vestido con mi “ropa de trabajo” mientras dure mi jornada laboral, y me cambio (o bien me pongo el pijama o algo más cómodo) cuando termino. Lo mismo cuando estoy haciendo algo personal o de ocio con el ordenador, dicen que lo ideal es separar incluso el equipo, es decir, usar el macbook para trabajar y el iPad para ver webs o mirar cosas ajenas al trabajo. Hay muchos trucos y a cada uno les servirá uno diferente, pero es importante tener esto en cuenta.</li><li><strong>Elige bien tu lugar de trabajo.</strong> Ya que tú eliges donde trabajas, hazlo bien. Vas a pasar muchas horas sentado, píllate una buena silla que se adapte a tu cuerpo, una mesa a tu altura y un buen monitor. Puedes estar cómodo y crearte tu ambiente. Hay gente que como mejor trabaja es con total silencio, otros con música e incluso hay gente que con la tele de fondo. Estás solo, no molestarás a nadie, elige la opción que más te guste. Incluso si tu casa no está preparada o no estás cómodo te puedes buscar un lugar cerca de donde vives, un co-working o cualquier sitio con conexión a internet donde te sientas bien.</li><li><strong>Debes de estar siempre motivado.</strong> Alguna vez que he trabajado en remoto me he distraído mucho y lo he achacado a lo que hemos visto antes, en casa hay muchas distracciones. De vuelta a la oficina veía que me distraía igual y quizás el problema no era dónde trabajaba, si no cual era mi trabajo. No estaba motivado con ese proyecto, no estaba bien gestionado ni organizado y veía las tareas que tenía que hacer un sin sentido. Es importante estar motivado siempre y más en remoto, así que si te pasa eso o bien consigue cambiar lo que falla del proyecto o, si es imposible, cambia de proyecto.</li><li><strong>Que hable tu trabajo.</strong> Uno de los miedos que se tiene al estar en casa (sobre todo cuando el resto del equipo está en la oficina) es que no se valore tu trabajo y eso te impida avanzar y mejorar dentro de la estructura de la empresa. No tengáis miedo a ello, que hable tu trabajo, si es bueno se te valorará. Hay que ser muy proactivo para que nadie se olvide que tú estás en el equipo y conseguir que solo mirando tu trabajo la gente ya te tengan muy presente.</li><li><strong>Vigila esos kilos.</strong> Precisamente esto me está pasando. Yo pensaba que iba a disponer de más tiempo para poder hacer ejercicio y comer mejor. Es algo que tengo que cambiar ya que no lo he conseguido, he terminado no sacando tiempo para estas dos tareas y no sabiendo gestionar el tiempo para que entren en mi día a día. Cuando vas a la oficina al menos te tienes que mover un poco pero estando en casa el movimiento de tu cuerpo tiende a cero. Hay que esforzarse más, sal a andar o correr, apúntate al gimnasio o queda para jugar algún partidito. Y dedícale tiempo a cocinar, tu cuerpo te lo agradecerá.</li></ul><p>Creo que saber trabajar en remoto es muy útil incluso si no trabajas así, intentar limitar las reuniones, tener una mejor comunicación y organización y ser capaz de trabajar de forma asíncrona teniendo la menor dependencia posible con tus compañeros. Tengo la intención de crearme un “manual de estilo” para llevar las mejores prácticas de esta forma de trabajar y compartirlo con mis compañeros y de paso compartirlo por aquí por si a alguien le sirve de utilidad.</p><p>P.D.: Escribiendo este texto me encuentro con un <a href="https://medium.com/@devsdna/3-a%C3%B1os-trabajando-en-remoto-5ce27518ce36">artículo</a> de una empresa española, <a href="http://www.devsdna.com/">Devsdna</a>, que trabaja en remoto y que comparte su experiencia trabajando en remoto durante 3 años, donde destaca dos cosas que he querido reflejar yo también aquí: confianza y felicidad.</p>]]></content:encoded></item></channel></rss>