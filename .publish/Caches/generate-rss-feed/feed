{"itemCount":4,"config":{"ttlInterval":250,"maximumItemCount":100,"targetPath":"feed.rss"},"feed":"<?xml version=\"1.0\" encoding=\"UTF-8\"?><rss version=\"2.0\" xmlns:atom=\"http:\/\/www.w3.org\/2005\/Atom\" xmlns:content=\"http:\/\/purl.org\/rss\/1.0\/modules\/content\"><channel><title>Alfonso Miranda<\/title><description>Mobile Software Engineer<\/description><link>http:\/\/alfonsomiranda.com<\/link><language>es<\/language><lastBuildDate>Mon, 12 Apr 2021 15:46:28 +0200<\/lastBuildDate><pubDate>Mon, 12 Apr 2021 15:46:28 +0200<\/pubDate><ttl>250<\/ttl><atom:link href=\"http:\/\/alfonsomiranda.com\/feed.rss\" rel=\"self\" type=\"application\/rss+xml\"\/><item><guid isPermaLink=\"true\">http:\/\/alfonsomiranda.com\/posts\/2021-04-05-tests-basic<\/guid><title>Tests en swift: Conceptos básicos<\/title><description>En cualquier proyecto software es muy importante que nuestro código esté testeado. En este artículo vamos a ver los conceptos básicos para comenzar a hacer tests en swift, que necesitamos saber y por qué son tan necesarios añadirlos en nuestros proyectos.<\/description><link>http:\/\/alfonsomiranda.com\/posts\/2021-04-05-tests-basic<\/link><pubDate>Mon, 5 Apr 2021 14:24:00 +0200<\/pubDate><content:encoded><![CDATA[<p>En todo este artículo los tests a los que nos vamos a referir son los tests unitarios. ¿Y qué son los tests unitarios? Según la <a href=\"https:\/\/es.wikipedia.org\/wiki\/Prueba_unitaria\">wikipedia<\/a>,<\/p><blockquote><p>una prueba unitaria es una forma de comprobar el correcto funcionamiento de una unidad de código es decir, desarrollar una serie de pruebas que comprueben el correcto funcionamiento de diferentes unidades de nuestro código implementado en nuestra aplicación.<\/p><\/blockquote><h1>¿Qué es un test y por qué lo necesito?<\/h1><p>En proyectos reales donde el tiempo siempre es escaso siempre se “olvidan” los tests aludiendo a que consumen tiempo de desarrollo y que no disponemos de él. Vamos a ver por qué son necesarios los tests:<\/p><h2>¡Porque nos ahorran tiempo!<\/h2><p>Si, la primera en la frente. Frente a las creencias de que nos consume mucho tiempo, la realidad es que es todo lo contrario. No solo el desarrollo de los tests es relativamente sencillo (si usamos una buena arquitectura, ya llegaremos a eso), si no que nos ahorra muchos problemas futuros, como malos funcionamientos, comportamientos no deseados, problemas colaterales a cambios en el código.<\/p><h2>Refactorización de código.<\/h2><p>Cuando uno se dispone a refactorizar un código por diferentes motivos (deuda técnica, cambios funcionales), y más si el código que estás modificando no es tuyo, siempre está el riesgo y el miedo a romper algo que no estamos teniendo en cuenta. Si todo ese código está testeado, el riesgo a tener problemas colaterales se reduce mucho (nunca podemos llegar a 0) y podemos cambiar este código con mucha más tranquilidad ya que los tests nos avisarán de que algo hemos roto y podremos controlarlo.<\/p><h2>Definición de los casos de uso.<\/h2><p>De algo que hablaremos en esta serie de artículos es de TDD que es, a MUY grandes rasgos, definir primero los tests y a partir de ellos desarrollar la implementación de nuestro proyecto. De esta forma, a partir de ir creando los tests podemos ir definiendo todos los casos de uso, y a partir de ellos definir todo el funcionamiento de la aplicación.<\/p><h2>Refinamiento del código.<\/h2><p>Si estamos construyendo tests de código ya implementado nos podemos dar cuenta en algún momento que nos resulta imposible testear alguna parte de nuestro código. ¿Es problema de que no sabemos hacer tests? No, seguramente es que el código está mal escrito y necesita ser mejorado. Esto nos ayuda a refactorizar este código y arreglarlo para que podamos desarrollar los tests, y de esta forma refinarlo y mejorarlo.<\/p><h2>Integración contínua.<\/h2><p>Si tenemos nuestro código en un sistema de integración continua, el tener implementado tests hará que no se suba código roto a entornos de desarrollo o producción, y que se controle que todo lo que debería funcionar, funcione. Hay muchas otras razones para usar tests, pero estas creo que son, en mi opinión, las más básicas.<\/p><h1>Conceptos básicos.<\/h1><p>Para añadir tests en tu proyecto se puede hacer o bien, si es un proyecto nuevo marcando que añade un target de test,<\/p><img src=\"http:\/\/alfonsomiranda.com\/images\/testBasics\/createProject.png\" alt=\"Crear nuevo proyecto con tests\" width=\"800\"\/><p>o en tu proyecto ya creado añadiendo ese target y asociarlo al principal.<\/p><img src=\"http:\/\/alfonsomiranda.com\/images\/testBasics\/addTestsProject.png\" alt=\"Seleccionamos un nuevo target de tests unit\" width=\"800\"\/><img src=\"http:\/\/alfonsomiranda.com\/images\/testBasics\/addTestsProject2.png\" alt=\"Ponemos su nombre y target\" width=\"800\"\/><p>Una vez hecho esto, con CMD + U ejecutamos los tests y nos lista los que han pasado y los que no.<\/p><img src=\"http:\/\/alfonsomiranda.com\/images\/testBasics\/firstTestsBuild.png\" alt=\"Ponemos su nombre y target\" width=\"800\"\/><p>Ahora vamos a hacer nuestro primer test. Para ello vamos a añadir en el ViewController creado por defecto una variable con un valor.<\/p><pre><code><span class=\"keyword\">import<\/span> UIKit\n\n<span class=\"keyword\">class<\/span> ViewController: <span class=\"type\">UIViewController<\/span> {\n    \n    <span class=\"keyword\">let<\/span> titleLabel: <span class=\"type\">UILabel<\/span> = {\n      <span class=\"keyword\">let<\/span> label = <span class=\"type\">UILabel<\/span>()\n      label.<span class=\"property\">text<\/span> = <span class=\"string\">\"Welcome\"<\/span>\n      <span class=\"keyword\">return<\/span> label\n    }()\n\n    <span class=\"keyword\">override func<\/span> viewDidLoad() {\n        <span class=\"keyword\">super<\/span>.<span class=\"call\">viewDidLoad<\/span>()\n        \n    }\n}\n<\/code><\/pre><p>Y añadimos un test para probarlo.<\/p><pre><code><span class=\"keyword\">func<\/span> test_viewController_titleLabel_is_welcome() {\n        <span class=\"keyword\">let<\/span> viewController = <span class=\"type\">ViewController<\/span>()\n        \n        <span class=\"call\">XCTAssertEqual<\/span>(viewController.<span class=\"property\">titleLabel<\/span>.<span class=\"property\">text<\/span>!, <span class=\"string\">\"Welcome\"<\/span>)\n    }\n<\/code><\/pre><p>Aquí lo único que hacemos es cargar el ViewController y comprobar que el texto que hay en el titleLabel es “Welcome”. Si ejecutamos <code>CMD + U<\/code> vemos que pasa el test sin problemas. Fácil, ¿no?<\/p><p>Seguimos y ahora añadimos en el Storyboard un label que enlazamos en el <code>ViewController<\/code> y en el viewDidLoad le asignamos un texto.<\/p><pre><code><span class=\"keyword\">import<\/span> UIKit\n\n<span class=\"keyword\">class<\/span> ViewController: <span class=\"type\">UIViewController<\/span> {\n    \n    <span class=\"keyword\">let<\/span> titleLabel: <span class=\"type\">UILabel<\/span> = {\n      <span class=\"keyword\">let<\/span> label = <span class=\"type\">UILabel<\/span>()\n      label.<span class=\"property\">text<\/span> = <span class=\"string\">\"Welcome\"<\/span>\n      <span class=\"keyword\">return<\/span> label\n    }()\n    \n    <span class=\"keyword\">@IBOutlet weak var<\/span> nameLabel: <span class=\"type\">UILabel<\/span>!\n\n    <span class=\"keyword\">override func<\/span> viewDidLoad() {\n        <span class=\"keyword\">super<\/span>.<span class=\"call\">viewDidLoad<\/span>()\n        \n        <span class=\"keyword\">self<\/span>.<span class=\"property\">nameLabel<\/span>.<span class=\"property\">text<\/span> = <span class=\"string\">\"Alfonso\"<\/span>\n    }\n}\n<\/code><\/pre><p>Ahora vamos a hacer su test. Si lo hacemos igual que antes veremos que no es que falle el test, es que nos da un crash. Esto es porque tenemos que cargar el ViewController a partir del Storyboard para que el nameLabel no sea nil, así que lo hacemos y comprobamos el texto igual que haciamos en el ejemplo anterior.<\/p><pre><code><span class=\"keyword\">func<\/span> test_viewController_nameLabel_is_Alfonso() {\n        <span class=\"keyword\">let<\/span> storyboard = <span class=\"type\">UIStoryboard<\/span>(name: <span class=\"string\">\"Main\"<\/span>, bundle: <span class=\"keyword\">nil<\/span>)\n        <span class=\"keyword\">let<\/span> viewController = storyboard\n            .<span class=\"call\">instantiateViewController<\/span>(withIdentifier: <span class=\"string\">\"viewController\"<\/span>) <span class=\"keyword\">as<\/span>! <span class=\"type\">ViewController<\/span>\n        \n        <span class=\"call\">XCTAssertEqual<\/span>(viewController.<span class=\"property\">nameLabel<\/span>.<span class=\"property\">text<\/span>!, <span class=\"string\">\"Alfonso\"<\/span>)\n    }\n<\/code><\/pre><p>Y si lo ejecutamos vemos que de nuevo nos da el mismo error, nameLabel nos sigue llegando nil. Nos falta que se ejecuten los eventos de un ViewController necesarios para que se cargue todo correctamente, y lo hacemos con beginAppearanceTransition de la siguiente forma:<\/p><pre><code><span class=\"keyword\">func<\/span> test_viewController_nameLabel_is_Alfonso() {\n        <span class=\"keyword\">let<\/span> storyboard = <span class=\"type\">UIStoryboard<\/span>(name: <span class=\"string\">\"Main\"<\/span>, bundle: <span class=\"keyword\">nil<\/span>)\n        <span class=\"keyword\">let<\/span> viewController = storyboard\n            .<span class=\"call\">instantiateViewController<\/span>(withIdentifier: <span class=\"string\">\"viewController\"<\/span>) <span class=\"keyword\">as<\/span>! <span class=\"type\">ViewController<\/span>\n        viewController.<span class=\"call\">beginAppearanceTransition<\/span>(<span class=\"keyword\">true<\/span>, animated: <span class=\"keyword\">false<\/span>)\n        <span class=\"call\">XCTAssertEqual<\/span>(viewController.<span class=\"property\">nameLabel<\/span>.<span class=\"property\">text<\/span>!, <span class=\"string\">\"Alfonso\"<\/span>)\n        viewController.<span class=\"call\">endAppearanceTransition<\/span>()\n    }\n<\/code><\/pre><p>Y ahora si que todo funciona correctamente y pasamos el test. El ejemplo es muy simple, pero si en algún momento se toca ese label y se cambia, el test fallará y así evitará que se cometa ese error, porque o bien se ha cambiado el label de manera equivocada o hay que actualizar el test para que asuma un nuevo funcionamiento.<\/p><p>Lo complicamos un poquito más, y añadimos dos textFields y un botón en nuestro ViewController. La idea es que en uno de los textField se escriba el nombre y en el otro el apellido, y que al darle al botón en el label se formatee correctamente poniendo el nombre, un espacio, y el apellido. El ViewController quedaría así.<\/p><pre><code><span class=\"keyword\">import<\/span> UIKit\n\n<span class=\"keyword\">class<\/span> ViewController: <span class=\"type\">UIViewController<\/span> {\n    \n    <span class=\"keyword\">let<\/span> titleLabel: <span class=\"type\">UILabel<\/span> = {\n      <span class=\"keyword\">let<\/span> label = <span class=\"type\">UILabel<\/span>()\n      label.<span class=\"property\">text<\/span> = <span class=\"string\">\"Welcome\"<\/span>\n      <span class=\"keyword\">return<\/span> label\n    }()\n    \n    <span class=\"keyword\">@IBOutlet weak var<\/span> nameLabel: <span class=\"type\">UILabel<\/span>!\n    <span class=\"keyword\">@IBOutlet weak var<\/span> composeButton: <span class=\"type\">UIButton<\/span>!\n    <span class=\"keyword\">@IBOutlet weak var<\/span> nameTextField: <span class=\"type\">UITextField<\/span>!\n    <span class=\"keyword\">@IBOutlet weak var<\/span> lastNmeTextField: <span class=\"type\">UITextField<\/span>!\n\n    <span class=\"keyword\">override func<\/span> viewDidLoad() {\n        <span class=\"keyword\">super<\/span>.<span class=\"call\">viewDidLoad<\/span>()\n        \n        <span class=\"keyword\">self<\/span>.<span class=\"property\">nameLabel<\/span>.<span class=\"property\">text<\/span> = <span class=\"string\">\"Alfonso\"<\/span>\n    }\n    \n    <span class=\"keyword\">@IBAction func<\/span> composeFullNameAction() {\n        <span class=\"keyword\">if let<\/span> name = nameTextField.<span class=\"property\">text<\/span>, <span class=\"keyword\">let<\/span> lastName = lastNmeTextField.<span class=\"property\">text<\/span> {\n            <span class=\"keyword\">self<\/span>.<span class=\"property\">nameLabel<\/span>.<span class=\"property\">text<\/span> = <span class=\"string\">\"<\/span>\\(name) \\(lastName)<span class=\"string\">\"<\/span>\n        }\n    }\n}\n<\/code><\/pre><p>Ahora tenemos que probar que tras pulsarse el botón el resultado en el label es el que nosotros esperamos, así que añadimos este test.<\/p><pre><code><span class=\"keyword\">func<\/span> test_viewController_compose_name_label() {\n        <span class=\"keyword\">let<\/span> storyboard = <span class=\"type\">UIStoryboard<\/span>(name: <span class=\"string\">\"Main\"<\/span>, bundle: <span class=\"keyword\">nil<\/span>)\n        <span class=\"keyword\">let<\/span> viewController = storyboard\n            .<span class=\"call\">instantiateViewController<\/span>(withIdentifier: <span class=\"string\">\"viewController\"<\/span>) <span class=\"keyword\">as<\/span>! <span class=\"type\">ViewController<\/span>\n        \n        viewController.<span class=\"call\">beginAppearanceTransition<\/span>(<span class=\"keyword\">true<\/span>, animated: <span class=\"keyword\">false<\/span>)\n        viewController.<span class=\"property\">nameTextField<\/span>.<span class=\"property\">text<\/span> = <span class=\"string\">\"alfonso\"<\/span>\n        viewController.<span class=\"property\">lastNmeTextField<\/span>.<span class=\"property\">text<\/span> = <span class=\"string\">\"miranda\"<\/span>\n        viewController.<span class=\"property\">composeButton<\/span>.<span class=\"call\">sendActions<\/span>(for: .<span class=\"dotAccess\">touchUpInside<\/span>)\n        <span class=\"call\">XCTAssertEqual<\/span>(<span class=\"string\">\"alfonso miranda\"<\/span>, viewController.<span class=\"property\">nameLabel<\/span>.<span class=\"property\">text<\/span>!)\n        viewController.<span class=\"call\">endAppearanceTransition<\/span>()\n    }\n<\/code><\/pre><p>Podemos ver que mediante el método sendActions del botón simulamos el touch en ese botón y podemos comprobar que el resultado es el deseado.<\/p><p>Aquí podemos probar lo que hablábamos antes. Como vemos, en el ejemplo he puesto tanto el nombre y el apellido empezando en minúscula (es un error pensado). Imaginad que en nuestra aplicación, aunque el usuario lo ponga empezando por minúscula lo formateamos y ponemos la primera letra en mayúsculas. Si hacemos ese cambio en el código y ejecutamos ese test, fallará. En este caso el comportamiento ha cambiado y tenemos que arreglar el test asegurando que en vez de lo anteriormente escrito ahora sea<\/p><pre><code><span class=\"call\">XCTAssertEqual<\/span>(<span class=\"string\">\"Alfonso Miranda\"<\/span>, viewController.<span class=\"property\">nameLabel<\/span>.<span class=\"property\">text<\/span>!)\n<\/code><\/pre><h1>Los pasos para un test: given, when, then.<\/h1><p>Hay una práctica llamada given, when, then, definido por Martin Fowler que se usa para hacer más ordenados y legibles los tests. Se trata de dividir en tres partes un test:<\/p><ul><li>Given: Correspondería con la preparación del test, cargarlo en el estado inicial, lo que en un caso de uso serían las pre-condiciones.<\/li><li>When: Se añaden las condiciones en las que queremos hacer el test.<\/li><li>Then: Se realiza el test y se obtienen los resultados.<\/li><\/ul><p>Swift no es una excepción, y podemos usar el último ejemplo del punto anterior para explicarlo. Given es la parte que prepara el test y carga lo que necesitamos, en este caso sería<\/p><pre><code><span class=\"keyword\">let<\/span> storyboard = <span class=\"type\">UIStoryboard<\/span>(name: <span class=\"string\">\"Main\"<\/span>, bundle: <span class=\"keyword\">nil<\/span>)\n<span class=\"keyword\">let<\/span> viewController = storyboard.<span class=\"call\">instantiateViewController<\/span>(withIdentifier: <span class=\"string\">\"viewController\"<\/span>) <span class=\"keyword\">as<\/span>! <span class=\"type\">ViewController<\/span>\n<\/code><\/pre><p>When sería:<\/p><pre><code>viewController.<span class=\"property\">nameTextField<\/span>.<span class=\"property\">text<\/span> = <span class=\"string\">\"alfonso\"<\/span>\nviewController.<span class=\"property\">lastNmeTextField<\/span>.<span class=\"property\">text<\/span> = <span class=\"string\">\"miranda\"<\/span>\nviewController.<span class=\"property\">composeButton<\/span>.<span class=\"call\">sendActions<\/span>(for: .<span class=\"dotAccess\">touchUpInside<\/span>)\n<\/code><\/pre><p>Y Then:<\/p><pre><code><span class=\"call\">XCTAssertEqual<\/span>(<span class=\"string\">\"Alfonso Miranda\"<\/span>, viewController.<span class=\"property\">nameLabel<\/span>.<span class=\"property\">text<\/span>!)\n<\/code><\/pre><h1>Mocks: qué son y cómo usarlos.<\/h1><p>Por último en esta introducción al maravilloso mundo de los tests vamos a hablar de los mocks, aunque esto lo veremos más detenidamente en el siguiente artículo donde hablaremos de testing con VIPER.<\/p><p>Cuando queremos testear una parte de nuestro código, una capa o una vista, podemos estar haciendo ahí uso de elementos que no son el objetivo de probarlo estos tests que estamos haciendo, si no que son una herramienta que usamos pero que deberían tener sus propios tests sin interferir en los de este trozo de código.<\/p><p>Un ejemplo sería cuando testeamos una vista que recibe una serie de datos para pintarlos en ella, de un servicio por ejemplo. Para testear esa vista no tenemos que probar que los servicios funcionan, si no que cuando se reciban los datos lo pintamos en el sitio correcto.<\/p><p>Vamos a hacer un ejemplo con este caso de uso en concreto. Imaginaros que tenemos un provider que consume un api rest que nos devuelve una película, con su descripción, su director y su año. Nos creamos el provider y un modelo para lo que nos devuelve la api y lo llamamos desde la vista. La llamada será desde un botón y lo pintaremos en un par de labels que añadimos en el storyboard y en el viewController. Vamos a dar por supuesto que tenemos el provider y el modelo hecho donde implementaremos un protocolo (al final del artículo pondré un enlace al proyecto completo).<\/p><p>Nuestro ViewController quedaría de la siguiente forma:<\/p><pre><code><span class=\"keyword\">import<\/span> UIKit\n\n<span class=\"keyword\">class<\/span> ViewController: <span class=\"type\">UIViewController<\/span> {\n    \n    <span class=\"keyword\">let<\/span> titleLabel: <span class=\"type\">UILabel<\/span> = {\n      <span class=\"keyword\">let<\/span> label = <span class=\"type\">UILabel<\/span>()\n      label.<span class=\"property\">text<\/span> = <span class=\"string\">\"Welcome\"<\/span>\n      <span class=\"keyword\">return<\/span> label\n    }()\n    \n    <span class=\"keyword\">var<\/span> movieProvider: <span class=\"type\">MovieProvider<\/span> = <span class=\"type\">MovieProviderImplementation<\/span>()\n    \n    <span class=\"keyword\">@IBOutlet weak var<\/span> nameLabel: <span class=\"type\">UILabel<\/span>!\n    <span class=\"keyword\">@IBOutlet weak var<\/span> composeButton: <span class=\"type\">UIButton<\/span>!\n    <span class=\"keyword\">@IBOutlet weak var<\/span> nameTextField: <span class=\"type\">UITextField<\/span>!\n    <span class=\"keyword\">@IBOutlet weak var<\/span> lastNmeTextField: <span class=\"type\">UITextField<\/span>!\n    <span class=\"keyword\">@IBOutlet weak var<\/span> titleMovieLabel: <span class=\"type\">UILabel<\/span>!\n    <span class=\"keyword\">@IBOutlet weak var<\/span> descriptionMovieLabel: <span class=\"type\">UILabel<\/span>!\n    <span class=\"keyword\">@IBOutlet weak var<\/span> getMovieButton: <span class=\"type\">UIButton<\/span>!\n\n    <span class=\"keyword\">override func<\/span> viewDidLoad() {\n        <span class=\"keyword\">super<\/span>.<span class=\"call\">viewDidLoad<\/span>()\n        \n        <span class=\"keyword\">self<\/span>.<span class=\"property\">nameLabel<\/span>.<span class=\"property\">text<\/span> = <span class=\"string\">\"Alfonso\"<\/span>\n    }\n    \n    <span class=\"keyword\">@IBAction func<\/span> composeFullNameAction() {\n        <span class=\"keyword\">if let<\/span> name = nameTextField.<span class=\"property\">text<\/span>, <span class=\"keyword\">let<\/span> lastName = lastNmeTextField.<span class=\"property\">text<\/span> {\n            <span class=\"keyword\">self<\/span>.<span class=\"property\">nameLabel<\/span>.<span class=\"property\">text<\/span> = <span class=\"string\">\"<\/span>\\(name.<span class=\"property\">capitalized<\/span>) \\(lastName.<span class=\"property\">capitalized<\/span>)<span class=\"string\">\"<\/span>\n        }\n    }\n    \n    <span class=\"keyword\">@IBAction func<\/span> getBestMovie() {\n        movieProvider.<span class=\"call\">getMovie<\/span>(success: { (movie) <span class=\"keyword\">in\n            self<\/span>.<span class=\"property\">titleMovieLabel<\/span>.<span class=\"property\">text<\/span> = movie.<span class=\"property\">title<\/span>\n            <span class=\"keyword\">self<\/span>.<span class=\"property\">descriptionMovieLabel<\/span>.<span class=\"property\">text<\/span> = movie.<span class=\"property\">movieEntityDescription<\/span>\n        }) { (error) <span class=\"keyword\">in<\/span>\n            <span class=\"call\">debugPrint<\/span>(<span class=\"string\">\"Error\"<\/span>)\n        }\n    }\n}\n<\/code><\/pre><p>Como vemos es lo descrito anteriormente, al pulsar el botón esperamos la respuesta, y cuando la tenemos rellenamos esos dos labels. Hemos creado una acción para ello y hemos además añadido un IBOutlet para el botón, que nos hará falta para realizar los tests.<\/p><p>Nuestro provider, llamado MovieProvider, implementa a este protocolo:<\/p><pre><code><span class=\"keyword\">protocol<\/span> MovieProvider {\n    <span class=\"keyword\">func<\/span> getMovie(success: <span class=\"keyword\">@escaping<\/span>(<span class=\"type\">MovieEntity<\/span>) -&gt; <span class=\"type\">Void<\/span>, failure: <span class=\"keyword\">@escaping<\/span>(<span class=\"type\">EError<\/span>) -&gt; <span class=\"type\">Void<\/span>)\n}\n<\/code><\/pre><p>Y nos ponemos a testear esto pero, ¿cómo lo hacemos?<\/p><p>Lo primero que pensaríamos en hacer una llamada real al servicio y testearlo pero esto tiene un problema: si el servicio falla, nuestros tests fallan, y sería engañoso ya que nuestro código está bien, lo que no está funcionando son los servicios y no es nuestra responsabilidad.<\/p><p>Así que vamos a hacer un mock de este provider en primer lugar:<\/p><pre><code><span class=\"keyword\">import<\/span> Foundation\n<span class=\"keyword\">@testable import<\/span> TestingBasic\n\n<span class=\"keyword\">class<\/span> MovieProviderMock: <span class=\"type\">MovieProvider<\/span> {\n    <span class=\"keyword\">var<\/span> isGetMovieCalled = <span class=\"keyword\">false\n    var<\/span> successState = <span class=\"keyword\">false\n    \n    func<\/span> getMovie(success: <span class=\"keyword\">@escaping<\/span> (<span class=\"type\">MovieEntity<\/span>) -&gt; <span class=\"type\">Void<\/span>, failure: <span class=\"keyword\">@escaping<\/span> (<span class=\"type\">EError<\/span>) -&gt; <span class=\"type\">Void<\/span>) {\n        <span class=\"keyword\">self<\/span>.<span class=\"property\">isGetMovieCalled<\/span> = <span class=\"keyword\">true\n        \n        if<\/span> successState {\n            <span class=\"keyword\">let<\/span> entity = <span class=\"type\">MovieEntity<\/span>(title: <span class=\"string\">\"Terminator 2\"<\/span>, year: <span class=\"string\">\"1992\"<\/span>, movieEntityDescription: <span class=\"string\">\"Un robot malo intentando matar a un niño\"<\/span>, director: <span class=\"string\">\"Steven Spilberg\"<\/span>)\n            <span class=\"call\">success<\/span>(entity)\n        }\n    }\n}\n<\/code><\/pre><p>Lo que estamos haciendo es hacer una implementación mockeada de nuestro provider. Tengo por costumbre, en primer lugar, tener un flag que me indique que ha ejecutado el método o no, para después en los tests comprobarlo. Además he añadido otro flag para indicar si quiero probar cuando ha ido todo bien o cuando ha habido un error, aunque en este caso solo he puesto salida para cuando todo ha ido correctamente.<\/p><p>En este caso me creo un MovieEntity (nuestro modelo) y lo devuelvo en el bloque de success.<\/p><p>Y con esto ya podemos crearnos nuestro test para comprobar qué pasa cuando le damos al botón de obtener la película, que sería de la siguiente forma:<\/p><pre><code><span class=\"keyword\">func<\/span> test_viewController_get_movie_when_is_success() {\n        <span class=\"comment\">\/\/GIVEN<\/span>\n        <span class=\"keyword\">let<\/span> storyboard = <span class=\"type\">UIStoryboard<\/span>(name: <span class=\"string\">\"Main\"<\/span>, bundle: <span class=\"keyword\">nil<\/span>)\n        <span class=\"keyword\">let<\/span> viewController = storyboard\n            .<span class=\"call\">instantiateViewController<\/span>(withIdentifier: <span class=\"string\">\"viewController\"<\/span>) <span class=\"keyword\">as<\/span>! <span class=\"type\">ViewController<\/span>\n        viewController.<span class=\"call\">beginAppearanceTransition<\/span>(<span class=\"keyword\">true<\/span>, animated: <span class=\"keyword\">false<\/span>)\n        <span class=\"comment\">\/\/WHEN<\/span>\n        <span class=\"keyword\">let<\/span> provider = <span class=\"type\">MovieProviderMock<\/span>()\n        provider.<span class=\"property\">successState<\/span> = <span class=\"keyword\">true<\/span>\n        viewController.<span class=\"property\">movieProvider<\/span> = provider\n        viewController.<span class=\"property\">getMovieButton<\/span>.<span class=\"call\">sendActions<\/span>(for: .<span class=\"dotAccess\">touchUpInside<\/span>)\n        <span class=\"comment\">\/\/THEN<\/span>\n        <span class=\"call\">XCTAssert<\/span>(provider.<span class=\"property\">isGetMovieCalled<\/span>)\n        <span class=\"call\">XCTAssert<\/span>(viewController.<span class=\"property\">titleMovieLabel<\/span>.<span class=\"property\">text<\/span> == <span class=\"string\">\"Terminator 2\"<\/span>)\n        viewController.<span class=\"call\">endAppearanceTransition<\/span>()\n    }\n<\/code><\/pre><p>Como podemos ver, el principio es similar a los anteriores tests, preparando en el GIVEN el test. En el WHEN inyectamos nuestro provider mockeado y “pulsamos” el botón de obtener la película. Y por último hacemos dos comprobaciones: que el método “GetMovie” ha sido llamado y que la respuesta se ha pintado en los labels correctos y con la información que esperábamos.<\/p><p>Es muy sencillo, en resumen todos los tests son similares a estos y en el siguiente artículo, usando VIPER como arquitectura, podremos profundizar más en estos conceptos.<\/p><p>Os dejo <a href=\"https:\/\/github.com\/alfonsomiranda\/Testing-in-swift\/tree\/basic\/TestingBasic\/TestingBasic\">aquí<\/a> todo el código del proyecto.<\/p>]]><\/content:encoded><\/item><item><guid isPermaLink=\"true\">http:\/\/alfonsomiranda.com\/posts\/2018-03-22-remote-work-team<\/guid><title>Trabajar con tu equipo en remoto<\/title><description>Hace unos días os comenté mis razones para trabajar en remoto. Para trabajar de esta forma es bueno que tanto tú como tu equipo sigáis unas buenas prácticas. He recopilado algunas que creo importantes y que algunas ya estoy aplicando en mi día a día y otras quiero ir añadiéndolas. Estas buenas prácticas no solo son necesarias si cada integrante del equipo está en su casa, si no cuando trabajamos con compañeros en otras oficinas, o incluso zonas separadas en la misma empresa.<\/description><link>http:\/\/alfonsomiranda.com\/posts\/2018-03-22-remote-work-team<\/link><pubDate>Thu, 22 Mar 2018 14:24:00 +0100<\/pubDate><content:encoded><![CDATA[<p>Hace unos días os comenté mis <a href=\"https:\/\/alfonsomiranda.com\/posts\/2018-01-26-remote-work\/\">razones para trabajar en remoto<\/a>. Para trabajar de esta forma es bueno que tanto tú como tu equipo sigáis unas buenas prácticas. He recopilado algunas que creo importantes y que algunas ya estoy aplicando en mi día a día y otras quiero ir añadiéndolas. Estas buenas prácticas no solo son necesarias si cada integrante del equipo está en su casa, si no cuando trabajamos con compañeros en otras oficinas, o incluso zonas separadas en la misma empresa.<\/p><h1>Comunicación.<\/h1><p>Hay que tener un buen canal de comunicación y saberlo usar. Si hay conversaciones o información entre personas que estén físicamente juntas hay que informar a los que estén en remoto. Es importante que haya este canal, pero hay que tener cuidado de que haya demasiados y diferentes canales que sean usados de manera irresponsable, transmitiendo un mensaje importante por un canal por donde solo se debería mensajes más superfluos. De esta forma el mensaje se puede perder y no tener claro por donde transmitirlo y por donde escucharlo. Y otra cosa importante relacionada con la comunicación es entender que debe de ser lo más asíncrona posible y que solo en momentos necesarios se necesite una respuesta rápida o una charla más profunda e inmediata.<\/p><h1>Update para sincronizarnos.<\/h1><p>Al estar separados físicamente es importante tener una pequeña reunión de 10–15 minutos al principio de la jornada para que todos los integrantes del equipo sepan en qué punto están, en que van a trabajar y que problemas y necesidades tienen. Esto no solo sirve para evitar confusiones o duplicidades en las tareas, si no que nos ayuda a hacer más equipo, a no aislarnos y sentirnos unidos en el trabajo que tenemos que realizar.<\/p><h1>Informa de tu status.<\/h1><p>Es importante que todo el equipo sepa en que estado estás, si estás trabajando en ese momento, si te has ido a comer, si tienes cita con el médico o has ido al gimnasio. De esta forma tu equipo sabrá si puede contar con tu ayuda o estás ausente. No hay que tener ningún problema en decir que haces, todos debemos ser responsables de nuestro trabajo y confiar en que todos estamos haciendo las tareas que nos corresponde.<\/p><h1>Utiliza la tecnología.<\/h1><p>Como ya vimos en el artículo anterior una de las excusas para no trabajar en remoto eran fácilmente solucionables con la tecnología. Antes era mucho más complicado trabajar en remoto porque la tecnología no acompañaba, las conexiones a internet eran lentas y no había las herramientas adecuadas. Hoy en día tenemos de todo a nuestro alcance para organizar el trabajo del equipo (jira, confluence, trello, basecamp), tener reuniones donde vernos las caras, compartir nuestro código, nuestra pantalla (skype, webex, appear.in) y para compartir archivos o documentos (dropbox, drive).<\/p><h1>Trabajo sincronizado, trabajo asíncrono.<\/h1><p>Una de las partes más importantes es evitar bloqueos en nuestro trabajo y en el de nuestros compañeros, así que hace falta tener una planificación clara del trabajo que tenemos que realizar en cada jornada antes de empezar (de ahí la importancia del daily). A veces, ni con esta planificación se puede evitar que haya algún bloqueo, así que es bastante recomendable coincidir al menos cuatro horas todo el equipo, y el resto de la jornada que cada uno elija el momento en el que sea más productivo.<\/p><h1>Compartir nuestro trabajo.<\/h1><p>Al no vernos las caras a diario es importante que hable nuestro trabajo y que nuestros compañeros estén informados de lo que hacemos y nos valoren por ello. Tenemos que hacer notar nuestra presencia de la mejor forma, comentar los commits de nuestros compañeros, hacer code reviews e incluso de vez en cuando hacer pair programming para solucionar algún problema complejo y aprender y mejorar de forma contínua.<\/p><h1>La fuente de agua.<\/h1><p>Algo de lo que ya he hablado en algún punto anterior de forma directa o indirecta es la importancia de hacer equipo. Una idea bastante buena que encontré en el libro Remote es tener una “fuente de agua”. Cuando estamos en la oficina muchas veces vamos a la fuente del agua\/máquina de café\/cocina y nos encontramos a algún compañero con el que tenemos una charla informal de cualquier tema, del partido del fútbol del fin de semana, de tus hijos (los padres somos muy pesados con este tema) o de las ganas que tienes de unas vacaciones. Esto lo podemos hacer en remoto creando un grupo\/chat donde poder compartir cosas más superfluas con nuestros compañeros y sobre todo usarlo. Enviar el último gif gracioso, comentar la noticia del día, cualquier tema es bueno para cuando queramos despejar un poco la mente del trabajo diario.<\/p><h1>Team buildings.<\/h1><p>Pese a trabajar en remoto a veces nos gusta tener contacto humano con nuestros compañeros y es algo que puede ayudar a mejorar las capacidades del equipo. Y es importante hacer de estas reuniones algo especial y que a todo el mundo le apetezca y le atraiga. Por supuesto, esto no debe ser algo impuesto y obligatorio ya que lo convertiría en una reunión más, y no es necesario que sea algo espectacular como un viaje al Caribe o ir a hacer parapente, con tomar unas cervezas y unas tapas todos juntos es más que suficiente. Seguro que hay muchas más prácticas que se me escapan o que tendría mejorar, ¿cuales son las tuyas?<\/p>]]><\/content:encoded><\/item><item><guid isPermaLink=\"true\">http:\/\/alfonsomiranda.com\/posts\/2018-01-26-remote-work<\/guid><title>¿Por qué trabajo en remoto?<\/title><description>Desde hace algunos meses ha cambiado mi forma de trabajar, de la forma clásica de ir a diario a la oficina y quedarme algún día en remoto (o el típico “¡los miércoles teletrabajo!”) a quedarme trabajando en remoto e ir a la oficina en casos muy puntuales y necesarios. Es lo llamado remote first y cada vez es una práctica más extendida en ciertos ámbitos como puede ser el desarrollo de software gracias a los avances de la tecnología y la facilidad que tenemos para desarrollar nuestro trabajo en cualquier sitio con las únicas herramientas de un portátil y una conexión a internet.<\/description><link>http:\/\/alfonsomiranda.com\/posts\/2018-01-26-remote-work<\/link><pubDate>Fri, 26 Jan 2018 14:24:00 +0100<\/pubDate><content:encoded><![CDATA[<p>Desde hace algunos meses ha cambiado mi forma de trabajar, de la forma clásica de ir a diario a la oficina y quedarme algún día en remoto (o el típico “¡los miércoles teletrabajo!”) a quedarme trabajando en remoto e ir a la oficina en casos muy puntuales y necesarios. Es lo llamado remote first y cada vez es una práctica más extendida en ciertos ámbitos como puede ser el desarrollo de software gracias a los avances de la tecnología y la facilidad que tenemos para desarrollar nuestro trabajo en cualquier sitio con las únicas herramientas de un portátil y una conexión a internet.<\/p><p>Soy muy defensor de esta práctica y recientemente me he terminado un buen libro sobre este tema llamado <a href=\"https:\/\/www.amazon.es\/Remote-Required-David-Heinemeier-Hansson\/dp\/0091954673\/\">Remote<\/a>, escrito por los cofundadores de <a href=\"http:\/\/37signals.com\/\">37signals.com<\/a>. Es una empresa donde todos sus trabajadores están en remoto (total o parcialmente), y pese a que este libro está escrito en el año 2014 es aún más válido hoy en día. Muchas de las ideas que exponen son cosas que ya rondaban por la cabeza y que ponía en práctica, pero reconforta mucho ver que uno no está loco por pensar de esta forma y que funciona en el mundo real.<\/p><p>Quiero comentaros algunos miedos que puede haber con esta forma de trabajar, las ventajas que conlleva y las buenas prácticas necesarias para que todo salga lo mejor posible. Gracias a este libro he podido poner mis ideas en orden y aquí quiero contaros desde mi perspectiva como poder llevarlo a cabo.<\/p><h1>Mis razones<\/h1><p>Lo primero que tenemos que preguntarnos es qué razones habría para trabajar en remoto. A nivel personal tenía éstas:<\/p><ul><li><strong>Ahorrar tiempo en desplazamientos.<\/strong> Me ponía muy nervioso tirarme una hora metido en mi coche, rodeado de otros muchos coches con gente cabreada, todos saliendo a la misma hora de camino a los mismos sitios, para llegar a la oficina, sentarme en mi sitio con una silla que no se adapta a mis problemas de espalda, sacar mi macbook de la mochila para conectarlo a un monitor más pequeño de lo que me gustaría y conectarme a una conexión a internet similar a la que tengo en casa. Ese viaje en coche (o en transporte público), además de la perdida de tiempo, conlleva mucho estrés y empezar mal el día. Trabajando en remoto puedo utilizar este tiempo para trabajar, teniendo la oportunidad de desayunar sin las prisas de salir antes de que el atasco sea aún mayor, teniendo el tiempo suficiente para ducharte y prepararte con tranquilidad (luego veremos que es importante no trabajar en pijama, al menos en mi opinión) y, en definitiva, empezar el día con ganas y no con desesperación.<\/li><li><strong>Interrupciones everywhere.<\/strong> Seguro que conocéis a mucha gente que intenta llegar antes que nadie a la oficina para tener una o dos horas en solitario y avanzar lo máximo posible (yo solía hacer esto), o se quedan cuando ya se han ido todos por la misma razón. En la oficina suele haber mil interrupciones, muchas de ellas innecesarias, con la excusa de que ya que te tienen al lado pueden “asaltarte” en cualquier momento. Suelen surgir las reuniones por cualquier razón, tu jefe puede venir varias veces para que le expliques como va tu trabajo (ese trabajo que no te está dejando hacer), aviso de tus compañeros para ir a desayunar justo en el momento que más productivo estás siendo y mucho más. Cuando estás en remoto las reuniones conllevan más preparación técnica y no es tan fácil como ir a tu sitio y meterte en una sala, con lo que muchas de esos encuentros se cambiarán por un mail o un mensaje, ya que realmente no eran tan importante como para hacer perder una hora a unos pocos de trabajadores. En casa nadie te molesta si tú no quieres, puedes ser eficiente y elegir cuando estás abierto a interrupciones.<\/li><li><strong>Conciliación familiar.<\/strong> Seguro que este concepto lo hemos escuchado mil veces, la famosa y necesaria conciliación familiar que muchas empresas lo arreglan dando un margen de entrada y otro de salida. Ésta es una de las razones más importantes para mi para trabajar en remoto, sobre todo desde que soy padre. El lujo de llevar a mi hijo al colegio por la mañana, de recogerle por la tarde, de estar disponible si tiene cualquier problema, si se pone malo, si hay que llevarlo al médico, de estar en su vida a diario y no solo verle unos minutos antes de que se vaya a dormir, todo eso es algo que tiene un valor incalculable y que, sin perder nada de eficiencia en mi trabajo, puedo hacer ahora sin problemas. Y muchas cosas más, si tengo médico no afecta tampoco a mi trabajo, cualquier gestión que solo se puede hacer por la mañana tampoco conlleva ausentarme de la oficina durante un tiempo o mil situaciones más que se nos puede ocurrir.<\/li><li><strong>Autogestión de mi tiempo.<\/strong> Este punto es casi un resumen de los puntos anteriores. Al trabajar en remoto no me tengo que ceñir a un horario estricto de oficina. Como hemos visto antes no tengo que coger mi coche y meterme en un atasco a las 7 de la mañana, si no que puedo empezar a trabajar cuando mi rendimiento sea mayor. En mi caso, de hecho, es incluso más temprano cuando me siento más productivo. Otros quizás sean más productivos por la noche, y de esta forma lo pueden aprovechar sin problemas. Esta gestión del tiempo nos permite esa conciliación familiar que veíamos en el punto anterior, el poder ir a hacer deporte o al gimnasio para estar un poco más en forma, el poder cocinar y comer más sano y tener una mayor calidad de vida sin que nuestro trabajo se vea perjudicado. Es importante saber trabajar de forma asíncrona con tus compañeros, pero siempre es recomendable coincidir un número de horas con ellos para evitar cualquier bloqueo.<\/li><\/ul><h1>¿Qué excusas existen para pensar que es una mala idea?<\/h1><p>No todo el mundo está de acuerdo con esta práctica y siempre surgirán mil excusas para afirmar que no se puede trabajar de esta forma, ya sea la empresa para la que trabajes, tu jefe, tus compañeros e incluso tú mismo.<\/p><p>Algunas que he oído, leído e incluso me he planteado yo mismo son las siguientes:<\/p><ul><li><strong>Trabajo en equipo.<\/strong> Creemos que si no estamos juntos no somos un equipo, no funcionamos como un equipo y las ideas no surgirán como cuando estamos físicamente juntos. Pensar así es un error, con la tecnología que tenemos hoy en día estamos a un click de poder estar hablando y viendo al resto del equipo y estar continuamente comunicados por chat\/email\/mensajería. Con todas estas herramientas podemos incluso compartir nuestro escritorio para que todo el equipo vea lo que estamos viendo, no existiendo ninguna diferencia con estar sentados el uno al lado del otro. El equipo no lo hace estar en un mismo espacio físico si no las personas y la buena comunicación entre ellas.<\/li><li><strong>Si no le veo, ¿estará trabajando?<\/strong> Esto es lo que pueden pensar muchos jefes, tener miedo a que tus trabajadores no estén trabajando sin vigilancia, como si fueran niños pequeños cuando no está la profe en clase. Si algún jefe te niega el trabajo en remoto por esta causa es un buen indicativo para saber que no confía en ti y en tu trabajo y quizás es hora de plantearse un cambio. Si tienes duda de que alguien trabaje cuando no le miras es más un problema de la contratación de esa persona que del trabajo en remoto. Muchas veces los jefes tienen una sensación de pérdida de control con esta práctica, pero seguro que en cuanto vea que la eficiencia y la productividad crecen esa sensación desaparecerá.<\/li><li><strong>En casa hay muchas distracciones.<\/strong> En casa tenemos la televisión, la videoconsola, quizás una lavadora que poner, una chapuza que hacer. Muchas distracciones. Pero realmente nada de esto nos distraerá si estamos motivados con nuestro trabajo y sabemos separar los tiempos para cada cosa. Es importante tener tu espacio de trabajo, saber y ser consciente de que cuando estás en ese sitio estás trabajando y tener una buena organización de tus tareas, objetivos y tiempos. Además, como hemos visto en la oficina también tenemos distracciones y muchas de ellas no depende de nosotros para evitarlas.<\/li><li><strong>Si otros no lo hacen …<\/strong> Esta era una duda para hacerlo en mi actual trabajo. Por norma nadie tiene un trabajo en remoto, existe la posibilidad de trabajar algún día en casa (dependiendo del proyecto) pero no de forma prioritaria como estoy yo en este momento. Por ello me surgía la duda de si el resto de compañeros me mirarían mal o creerían que me estaban dando un privilegio especial. Todo lo contrario, al final todo es más natural de lo que parece, todos saben mi situación y el que habla es mi trabajo. Incluso si algún día existe la necesidad de ir por la oficina me consultan mi disponibilidad y me avisan con el tiempo suficiente. Si mis resultados son buenos ni a mis compañeros ni a mis jefes les importa desde donde lo estoy haciendo.<\/li><\/ul><h1>¡Ojo, cuidado!<\/h1><p>Existen verdaderos peligros cuando trabajamos en remoto, pero al contrario de lo que se pueda pensar no es no trabajar si no trabajar demasiado. Esto puede pasar por una serie de circunstancia que he ido viendo en este tiempo.<\/p><ul><li><strong>Crea una rutina.<\/strong> Todo el mundo piensa que trabajar en casa es equivalente a sentarse frente al ordenador en pijama mientras te quitas las legañas recién levantado. A alguien le funcionará esto, pero yo no lo recomiendo. Lo importante es crearse una rutina, levantarte, ducharte, vestirte, desayunar y ponerte a trabajar como si fueras a la oficina. Intentar hacerlo siempre en el mismo horario también ayudará ya que puedes correr el riesgo de estar todo el día trabajando, es decir, no delimitar ni cuando empiezas ni cuando acabas puede llevarte a ponerte a las 8 de la mañana y terminar a las 10 de la noche, quizás no de forma continuada. Yo también necesito tener mucha más organización que estando en la oficina, tener claras mis tareas y las horas de trabajo para no hacer ni más (te terminarás quemando) ni menos.<\/li><li><strong>Cuidado con aislarnos demasiado.<\/strong> El estar trabajando solo te puede llevar a aislarte y eso te termina encaminando a, de nuevo, trabajar demasiado, no hablar con nadie y quemarte. Es importante tener comunicación con tu equipo, y no solo para hablar de trabajo si no para tener alguna conversación superflua. También es necesario tener relaciones personales con amigos o familia. En este punto lo tengo fácil, tengo un hijo que tiene mil historias que contarme, así que tengo bastante cubierto el no aislarme nunca.<\/li><li><strong>Equilibrio entre trabajo y vida.<\/strong> Tiene mucha relación con los dos puntos anteriores, hay que saber tener un equilibrio entre tu lado profesional y personal. Si lo mezclas demasiado terminas perjudicando tu trabajo y tu vida personal. El apunte de vestirte y no trabajar en pijama para mi es muy importante. Puede ser que un día no salga en todo el día de casa por cualquier razón, pero estoy vestido con mi “ropa de trabajo” mientras dure mi jornada laboral, y me cambio (o bien me pongo el pijama o algo más cómodo) cuando termino. Lo mismo cuando estoy haciendo algo personal o de ocio con el ordenador, dicen que lo ideal es separar incluso el equipo, es decir, usar el macbook para trabajar y el iPad para ver webs o mirar cosas ajenas al trabajo. Hay muchos trucos y a cada uno les servirá uno diferente, pero es importante tener esto en cuenta.<\/li><li><strong>Elige bien tu lugar de trabajo.<\/strong> Ya que tú eliges donde trabajas, hazlo bien. Vas a pasar muchas horas sentado, píllate una buena silla que se adapte a tu cuerpo, una mesa a tu altura y un buen monitor. Puedes estar cómodo y crearte tu ambiente. Hay gente que como mejor trabaja es con total silencio, otros con música e incluso hay gente que con la tele de fondo. Estás solo, no molestarás a nadie, elige la opción que más te guste. Incluso si tu casa no está preparada o no estás cómodo te puedes buscar un lugar cerca de donde vives, un co-working o cualquier sitio con conexión a internet donde te sientas bien.<\/li><li><strong>Debes de estar siempre motivado.<\/strong> Alguna vez que he trabajado en remoto me he distraído mucho y lo he achacado a lo que hemos visto antes, en casa hay muchas distracciones. De vuelta a la oficina veía que me distraía igual y quizás el problema no era dónde trabajaba, si no cual era mi trabajo. No estaba motivado con ese proyecto, no estaba bien gestionado ni organizado y veía las tareas que tenía que hacer un sin sentido. Es importante estar motivado siempre y más en remoto, así que si te pasa eso o bien consigue cambiar lo que falla del proyecto o, si es imposible, cambia de proyecto.<\/li><li><strong>Que hable tu trabajo.<\/strong> Uno de los miedos que se tiene al estar en casa (sobre todo cuando el resto del equipo está en la oficina) es que no se valore tu trabajo y eso te impida avanzar y mejorar dentro de la estructura de la empresa. No tengáis miedo a ello, que hable tu trabajo, si es bueno se te valorará. Hay que ser muy proactivo para que nadie se olvide que tú estás en el equipo y conseguir que solo mirando tu trabajo la gente ya te tengan muy presente.<\/li><li><strong>Vigila esos kilos.<\/strong> Precisamente esto me está pasando. Yo pensaba que iba a disponer de más tiempo para poder hacer ejercicio y comer mejor. Es algo que tengo que cambiar ya que no lo he conseguido, he terminado no sacando tiempo para estas dos tareas y no sabiendo gestionar el tiempo para que entren en mi día a día. Cuando vas a la oficina al menos te tienes que mover un poco pero estando en casa el movimiento de tu cuerpo tiende a cero. Hay que esforzarse más, sal a andar o correr, apúntate al gimnasio o queda para jugar algún partidito. Y dedícale tiempo a cocinar, tu cuerpo te lo agradecerá.<\/li><\/ul><p>Creo que saber trabajar en remoto es muy útil incluso si no trabajas así, intentar limitar las reuniones, tener una mejor comunicación y organización y ser capaz de trabajar de forma asíncrona teniendo la menor dependencia posible con tus compañeros. Tengo la intención de crearme un “manual de estilo” para llevar las mejores prácticas de esta forma de trabajar y compartirlo con mis compañeros y de paso compartirlo por aquí por si a alguien le sirve de utilidad.<\/p><p>P.D.: Escribiendo este texto me encuentro con un <a href=\"https:\/\/medium.com\/@devsdna\/3-a%C3%B1os-trabajando-en-remoto-5ce27518ce36\">artículo<\/a> de una empresa española, <a href=\"http:\/\/www.devsdna.com\/\">Devsdna<\/a>, que trabaja en remoto y que comparte su experiencia trabajando en remoto durante 3 años, donde destaca dos cosas que he querido reflejar yo también aquí: confianza y felicidad.<\/p>]]><\/content:encoded><\/item><item><guid isPermaLink=\"true\">http:\/\/alfonsomiranda.com\/posts\/2017-01-20-clean-architecture-viper<\/guid><title>Clean architecture en iOS: VIPER<\/title><description>En los últimos tiempos está muy de moda en el mundo del software la filosofía “clean”, hacer de la construcción de software un arte, y que estemos orgullosos del código que escribimos. Seguramente el mayor defensor de esta filosofía, o al menos el que más ha escrito al respecto sea Robert C. Martin, más conocido como Uncle Bob, y en este texto me basaré en mucho de lo que él ha escrito y contado. También hay que hacer alguna referencia a otros autores, como el conocido Gangs of four, los cuales escribieron mucho sobre patrones de diseño o Martin Fawler, el cual colaboró con Robert C. Martin en la definición de SOLID (que veremos más adelante) y escribió un libro imprescindible llamado Refactoring.<\/description><link>http:\/\/alfonsomiranda.com\/posts\/2017-01-20-clean-architecture-viper<\/link><pubDate>Fri, 20 Jan 2017 14:24:00 +0100<\/pubDate><content:encoded><![CDATA[<p>En los últimos tiempos está muy de moda en el mundo del software la filosofía “clean”, hacer de la construcción de software un arte, y que estemos orgullosos del código que escribimos.<\/p><p>Seguramente el mayor defensor de esta filosofía, o al menos el que más ha escrito al respecto sea <a href=\"https:\/\/en.wikipedia.org\/wiki\/Robert_Cecil_Martin\">Robert C. Martin<\/a>, más conocido como Uncle Bob, y en este texto me basaré en mucho de lo que él ha escrito y contado. También hay que hacer alguna referencia a otros autores, como el conocido Gangs of four, los cuales escribieron mucho sobre patrones de diseño o <a href=\"https:\/\/es.wikipedia.org\/wiki\/Martin_Fowler\">Martin Fawler<\/a>, el cual colaboró con Robert C. Martin en la definición de SOLID (que veremos más adelante) y escribió un libro imprescindible llamado <a href=\"https:\/\/www.amazon.es\/Refactoring-Improving-Design-Existing-Technology\/dp\/0201485672\/ref=sr_1_1?ie=UTF8&qid=1484827579&sr=8-1&keywords=refactoring\">Refactoring<\/a>.<\/p><h1>Clean architecture.<\/h1><p>Robert C. Martin fue el que definió esta arquitectura allá por el año 2012 en su <a href=\"https:\/\/8thlight.com\/blog\/uncle-bob\/2012\/08\/13\/the-clean-architecture.html\">web<\/a>. Existían entonces, y siguen existiendo, muchas arquitecturas definidas que intentan solucionar los mismos problemas:<\/p><ul><li><strong>Independiente de frameworks.<\/strong> Debemos hacer la arquitectura independiente de cualquier librería que usemos en el desarrollo, y que no nos aten a sus requisitos, usándolas como lo que son, herramientas para conseguir un fin concreto.<\/li><li><strong>Testeable.<\/strong> La lógica de negocio se debería poder testear sin necesidad de la interfaz de usuario (UI), base de datos, servidor web u otras herramientas externas, y de esta forma eliminar elementos que son más complicados de probar.<\/li><li><strong>Independiente de la UI.<\/strong> Como la interfaz de usuario suele ser el elemento que más expuesto está al cambio debemos asegurarnos que no afecten al resto del desarrollo. De esta forma, además, se podrá usar un mismo código para diferentes interfaces solo cambiando la capa de UI.<\/li><li><strong>Independiente de la base de datos.<\/strong> De forma similar al punto anterior, al ser la arquitectura independiente de la base de datos, o más genéricamente, de la fuente de datos, podemos hacer cambios en esta parte sin que afecte a la lógica de negocio, teniendo la posibilidad de cambiar una api por un webservice, una base de datos por una api, o cualquier combinación que se nos ocurra.<\/li><li><strong>Independiente de factores externos.<\/strong> Como resumen al resto de puntos, la lógica de negocio debe ser ajena a todo lo que venga del mundo exterior, pudiendo cambiar el resto de piezas sin que le afecte, como si de un puzzle se tratara.<\/li><\/ul><p>Como hemos comentado, las arquitecturas existententes solucionaban la mayoría de estos puntos y todas separaban la arquitectura en capas para diferenciar los diferentes conceptos, pero algunas estaban más enfocadas a la interfaz y otras a la lógica de negocio.<\/p><p>En el caso concreto de iOS, la más usada era (y es) MVC, aunque habitualmente esas siglas perdían su significado de “Model View Controller”, para pasar a ser “Massive View Controller”, al terminar siendo cualquier clase u objeto una vista, modelo y controlador a la vez, terminando por desvirtualizar e incluso elimininar la arquitectura.<\/p><img src=\"http:\/\/alfonsomiranda.com\/images\/cleanArchitecture\/cleanArchitectureDiagraman.png\" alt=\"The Clean Architecture, by Uncle Bob\" width=\"800\"\/><p>En este diagrama se intentó unificar todas estas ideas en una sola, que fuera entendible y que cumpliera una serie de reglas.<\/p><h2>Reglas de dependencia.<\/h2><p>Los diferentes círculos representan diferentes capas del software. En general, cuanto mas nos alejemos del núcleo mayor es el nivel del software y más unido al framework está. Los círculos exteriores son mecanismos mientras que los interiores son políticas. La regla primordial que hace que esta arquitectura funcione es la regla de dependencia. Esta regla dice que las dependencias a nivel de código fuente sólo pueden apuntar hacia dentro. Nada que se encuentre en un circulo interior puede saber algo sobre lo que hay en un círculo exterior, es decir, algo declarado en un círculo externo no puede ser mencionado desde el código situado en un círculo interno. Eso incluye funciones, clases, variables o cualquier otra entidad software. Por la misma razón, los formatos de datos usados en un círculo exterior no deberían usarse por un círculo interior, especialmente si esos formatos son generados por algún framework en un círculo situado al exterior. No queremos que nada de un círculo exterior impacte en los círculos o niveles interiores.<\/p><h2>Entities<\/h2><p>Las entidades son usadas por la lógica de negocio de la aplicación, por los llamados interactors. Deben ser objetos que solo dependan de esta capa y que no deben ser usados por las capas superiores, teniendo éstas que funcionar con objetos más simples (diccionarios, arrays, struts, …) o con parámetros de una función.<\/p><h2>User Cases<\/h2><p>En esta capa, también llamada Interactor, se tienen los casos de uso, lo cual tienen que ser independiente de la fuente de datos o de la visualización de los mismos. Si cambia los datos no debe influir en estos casos de uso, al igual que si la apariencia de nuestro desarrollo cambia. Es donde tendremos la lógica de negocio en nuestra aplicación<\/p><h2>Interface adapters<\/h2><p>O también llamados Presenters, es la capa que comunica los resultados de los casos de uso con la capa más externa. Esta capa recogerá los datos del interactor que a su vez los habrá procesado de la fuente de datos, y los formateará para ser presentado en la capa más externa, ya sea en una UI, en una base de datos o en algún dispositivo.<\/p><h2>Frameworks y adapters<\/h2><p>Es la capa más externa y la más pegada a la tecnología que estamos usando. En una web sería el html\/javascript, en una app iOS todo lo referente a UIKit. Esta capa es una de las que está más sujeta a cambios, y la que podemos hacer más intercambiable. Si nos enfocamos en iOS, solo (o casi) cambiando esta capa podremos adaptar nuestra aplicación a iPhone, iPad o Apple TV.<\/p><h2>Cruzando los límites, ¿cómo y qué puede cruzarlos?<\/h2><p>La forma en la que debemos comunicarnos entre capa sería a través de interfaces, protocolos o delegados. Debe ser lo más polimórfico posible y que no cause mucho daño el cambio de una de las capas, siempre respetando la interfaz. Si jugamos con protocolos haremos estas comunicaciones totalmente independiente las unas de las otras, y serán piezas fácilmente intercambiables. Desde la llegada de swift ha proliferado la llamada OPP (Programación orientada a protocolos), la cual, entre otras muchas cosas, ayuda mucho a este cometido.<\/p><h1>SOLID<\/h1><p>Antes de hablar de VIPER me gustaría comentar algo sobre <a href=\"https:\/\/en.wikipedia.org\/wiki\/SOLID_(object-oriented_design\">SOLID<\/a>). Para el que aún no lo conozca, <a href=\"https:\/\/en.wikipedia.org\/wiki\/SOLID_(object-oriented_design\">SOLID<\/a>) es una serie de principios básicos definidos por varios autores para el desarrollo orientado a objetos, unificados en este acrónimo inventado por nuestro Uncle Bob. Vamos a echarle un vistazo rápido a cada uno de ellos.<\/p><ul><li><strong>S: Single responsibility principle:<\/strong> Una clase debería solo tener una responsabilidad, es decir, solo debería de tener una razón para cambiar. Dicho de otra forma, cuando una clase o función es usada para más de una cosa suele ser causa de estar haciendo algo mal. Esto parece algo muy lógico y básico, pero muchas veces no se cumplen y terminamos haciendo pequeñas tareas en funcionalidades ya existentes porque “nos pilla más a mano”, terminando por ser un problema a la larga cuando ese método lo queramos usar en otro sitio, teniendo que recordar que también sirve para más cosas. Por ejemplo, si tenemos un método que imprime un documento, y en algún momento también añadimos ahí que se guarde en disco, si en otro lugar queremos imprimir tendríamos el problema de que también hará otras funciones no deseadas y que quizás ni recordemos que estaban ahí.<\/li><li><strong>O: Open\/closed principle (Bertrand Meyer):<\/strong> Una clase debería ser abierta por extensión, pero nunca por modificación. Es decir, se puede heredar de esa clase, extenderla, pero nunca modificar su código fuente para adaptarla a todos los casos. La forma más fácil de extender una clase es con herencia o interfaces (protocolos en nuestro caso). Este principio puede parecer fácil pero no lo es tanto, ya que tenemos que tener bastante claro la definición de nuestro proyecto, y preveer que clases vamos a tener que extender, no siendo siempre posible y teniendo en algún momento que necesitar refactorizar.<\/li><li><strong>L: Liskov substitution principle (Barbara Liskov):<\/strong> Los objetos de un programa deberían de ser sustituidos por una subclase o instancia sin modificar el comportamiento del programa. Es decir, una clase que herede de otra no tiene que modificar el comportamiento de la clase base de tal forma que al sustituirlo por ella el comportamiento sea diferente. La forma más fácil de ver si estamos cumpliendo esta regla es sustituir en nuestro código la clase base por cualquiera de las subclases y ver si todo sigue funcionando igual.<\/li><li><strong>I: Interface segregation principle (Robert C. Martin):<\/strong> Muchos pequeños y específicos interfaces son mejores que uno genérico. Esto evita el acoplamiento y fomenta la segregación. Es parecido al primer principio pero orientado a interfaces, las cuales deben ser para un caso de uso concreto y no demasiado genérica. El objetivo de este principio es principalmente poder reaprovechar los interfaces en otras clases. Si tenemos un interface que compara y clona en el mismo interface, de manera más complicada se podrá utilizar en una clase que solo debe comparar o en otra que solo debe clonar.<\/li><li><strong>D: Dependency inversion principle (Robert C. Martin):<\/strong> Se debe depender de abstracciones, no de concreciones. Esto fomenta el uso de interfaces y es algo que ya hemos hablado antes en clean arquitecture, que debería ser la forma en la que se comunican las diferentes capas. De esta forma unas clases pueden interacturar con otras sin conocer toda su implementación, usando, por ejemplo, inyección de dependencias.<\/li><\/ul><h1>VIPER<\/h1><p>VIPER no es más que una implementación de esta arquitectura, orientada a un desarrollo iOS. VIPER es un conjunto de siglas que describen las diferentes capas, View, Interactor, Presenter, Entity y Routing.<\/p><img src=\"http:\/\/alfonsomiranda.com\/images\/cleanArchitecture\/viperDiagraman.png\" alt=\"VIPER\" width=\"800\"\/><ul><li><strong>View:<\/strong> Capa que “pinta” lo que le mande el presenter y que, mediante los inputs del usuario le pregunta al presenter qué hacer. Esta capa tiene que ser totalmente pasiva, lo más “tonta” posible y tendrá dos formas de reaccionar: a los inputs externos (touch de un usuario, por ejemplo) o a órdenes del presenter.<\/li><li><strong>Interactor:<\/strong> Contiene la lógica de negocio de un caso de uso. Aquí se manipula las Entities (modelos) para una tarea específica. Como ya hemos dicho debe ser independiente de la interfaz gráfica y debe modelar lo recibido de una fuente de datos. Al hacerlo independiente de la interfaz este código debería ser compatible para desarrollar, por ejemplo, para iOS y OSX sin ningún problema.<\/li><li><strong>Presenter:<\/strong> Contiene la lógica que la vista tiene que presentar y reacciona a los inputs que desde la vista son mandadas. Esto quiere decir que le dirá a la UI que tiene que pintar al recibir la información del Interactor y reaccionará a las acciones de la View (UI) para hacer una navegación o pedir datos.<\/li><li><strong>Entity:<\/strong> Contiene el modelo de los objetos usados por el Interactor. Será, normalmente, un simple PONSO, o si estamos usando CoreData serán los NSManagedObjects generados.<\/li><li><strong>Routing:<\/strong> Contiene toda la navegación de la app. Es quizás la más complicada de entender al estar acostumbrados hasta ahora a hacer toda la navegación en los ViewController. Este Routing (también llamados Wireframe) son aprovechados para hacer la inyección de dependencias a la hora de crear una nueva navegación y presentar una nueva sección. Existen muchas formas de implementar esta parte y suele ser motivo de discusión de darle o no más responsabilidad. Lo importante es que en esta capa esté concentrado toda la navegación de la app.<\/li><\/ul><p>Esta separación cumple la <a href=\"http:\/\/www.objectmentor.com\/resources\/articles\/srp.pdf\">Single Responsibility Principle<\/a>. El Interactor es responsable de la lógica de negocio, el Presenter representa la interacción con el diseño y la View es responsable del diseño visual.<\/p><p>También es importante que cumpla la norma “Dependency segregation principle”, ya que a la hora de conectar las diferentes capas deberíamos hacerlo con interfaces, protocolos, y de esta forma depender de estas abstracciones y no de implementaciones concretas, pudiendo de esta forma cambiar la implementación de una capa sin que afecte a otras.<\/p><p>Los otros tres principios también deben ser cumplidos, en realidad cualquier arquitectura orientada a objetos debería cumplir SOLID, y aunque no sea fácil debemos obligarnos a ello.<\/p><p>Si en algún momento no estamos cumpliendo las diferentes buenas prácticas y normas no debemos tener miedo a refactorizar y siempre intentar mejorar el código. Si no sabéis qué es <a href=\"https:\/\/es.wikipedia.org\/wiki\/Teor%C3%ADa_de_las_ventanas_rotas\">la teoría de las ventanas rotas<\/a> os invito a conocerla.<\/p><p>Para terminar, os dejo un poco de documentación y bibliografía en la que me he apoyado y basado para escribir esto:<\/p><ul><li>Clean arquitecture: <a href=\"https:\/\/8thlight.com\/blog\/uncle-bob\/2012\/08\/13\/the-clean-architecture.html\">https:\/\/8thlight.com\/blog\/uncle-bob\/2012\/08\/13\/the-clean-architecture.html<\/a><\/li><li>VIPER: <a href=\"https:\/\/www.objc.io\/issues\/13-architecture\/viper\/\">https:\/\/www.objc.io\/issues\/13-architecture\/viper\/<\/a><\/li><li>SOLID: <a href=\"https:\/\/www.genbetadev.com\/paradigmas-de-programacion\/solid-cinco-principios-basicos-de-diseno-de-clases\">https:\/\/www.genbetadev.com\/paradigmas-de-programacion\/solid-cinco-principios-basicos-de-diseno-de-clases<\/a><\/li><li>Clean Arquitecture by Robert C. Martin: <a href=\"https:\/\/www.amazon.es\/Clean-Architecture-Robert-C-Martin\/dp\/0134494164\/\">https:\/\/www.amazon.es\/Clean-Architecture-Robert-C-Martin\/dp\/0134494164\/<\/a><\/li><li>Refactoring: <a href=\"https:\/\/www.amazon.es\/Refactoring-Improving-Design-Existing-Technology\/dp\/0201485672\/\">https:\/\/www.amazon.es\/Refactoring-Improving-Design-Existing-Technology\/dp\/0201485672\/<\/a><\/li><\/ul>]]><\/content:encoded><\/item><\/channel><\/rss>"}