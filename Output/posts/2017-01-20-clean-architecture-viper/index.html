<!DOCTYPE html><html lang="es"><head><title>Alfonso Miranda - Mobile Software Engineer</title><meta name="twitter:title" content="Alfonso Miranda - Mobile Software Engineer"/><meta name="og:title" content="Alfonso Miranda - Mobile Software Engineer"/><meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css"/><link rel="stylesheet" href="/Pure/styles.css"/><link rel="stylesheet" href="/all.css"/></head><body><div id="layout" class="pure-g"><div><div class="pure-menu pure-menu-horizontal pure-u-1-1 top-header"><ul class="pure-menu-list"><li class="pure-menu-item"><a class="pure-menu-link" href="/about">Sobre mi</a></li></ul></div></div><div class="sidebar pure-u-1 pure-u-md-1-4"><div class="header"><div id="layout" class="pure-g"><div class="pure-u-md-1-1 pure-u-3-4"><h1><a class="brand-title" href="/">Alfonso Miranda</a></h1><h3 class="brand-tagline">Mobile Software Engineer</h3></div></div><div id="layout" class="pure-g"><div class="pure-u-md-1-1"><a href="https://www.linkedin.com/in/alfonsomirandacastro/"><i class="fab fa-linkedin l-box social-icon"></i><a class="social-media" href="https://www.linkedin.com/in/alfonsomirandacastro/">LinkedIn</a></a></div><div class="pure-u-md-1-1"><a href="https://github.com/alfonsomiranda"><i class="fab fa-github-square l-box social-icon"></i><a class="social-media" href="https://github.com/alfonsomiranda">GitHub</a></a></div><div class="pure-u-md-1-1"><a href="https://twitter.com/alfonsobeta"><i class="fab fa-twitter-square l-box social-icon"></i><a class="social-media" href="https://twitter.com/alfonsobeta">Twitter</a></a></div><div class="pure-u-md-1-1"><a href="https://www.twitch.tv/alfonsomiranda"><i class="fab fa-twitch l-box social-icon"></i><a class="social-media" href="https://www.twitch.tv/alfonsomiranda">Twitch</a></a></div></div></div></div><div class="content pure-u-1 pure-u-md-3-5 pure-u-xl-6-10"><h2 class="post-title"><a href="/posts/2017-01-20-clean-architecture-viper">Clean architecture en iOS: VIPER</a></h2><p class="post-meta">20 de enero de 2017</p><div class="post-tags"><a class="post-category post-category-clean architecture" href="/tags/clean-architecture">clean architecture</a><a class="post-category post-category-clean" href="/tags/clean">clean</a><a class="post-category post-category-viper" href="/tags/viper">viper</a><a class="post-category post-category-swift" href="/tags/swift">swift</a><a class="post-category post-category-solid" href="/tags/solid">solid</a></div><div class="post-description"><div><p>En los últimos tiempos está muy de moda en el mundo del software la filosofía “clean”, hacer de la construcción de software un arte, y que estemos orgullosos del código que escribimos.</p><p>Seguramente el mayor defensor de esta filosofía, o al menos el que más ha escrito al respecto sea <a href="https://en.wikipedia.org/wiki/Robert_Cecil_Martin">Robert C. Martin</a>, más conocido como Uncle Bob, y en este texto me basaré en mucho de lo que él ha escrito y contado. También hay que hacer alguna referencia a otros autores, como el conocido Gangs of four, los cuales escribieron mucho sobre patrones de diseño o <a href="https://es.wikipedia.org/wiki/Martin_Fowler">Martin Fawler</a>, el cual colaboró con Robert C. Martin en la definición de SOLID (que veremos más adelante) y escribió un libro imprescindible llamado <a href="https://www.amazon.es/Refactoring-Improving-Design-Existing-Technology/dp/0201485672/ref=sr_1_1?ie=UTF8&qid=1484827579&sr=8-1&keywords=refactoring">Refactoring</a>.</p><h1>Clean architecture.</h1><p>Robert C. Martin fue el que definió esta arquitectura allá por el año 2012 en su <a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html">web</a>. Existían entonces, y siguen existiendo, muchas arquitecturas definidas que intentan solucionar los mismos problemas:</p><ul><li><strong>Independiente de frameworks.</strong> Debemos hacer la arquitectura independiente de cualquier librería que usemos en el desarrollo, y que no nos aten a sus requisitos, usándolas como lo que son, herramientas para conseguir un fin concreto.</li><li><strong>Testeable.</strong> La lógica de negocio se debería poder testear sin necesidad de la interfaz de usuario (UI), base de datos, servidor web u otras herramientas externas, y de esta forma eliminar elementos que son más complicados de probar.</li><li><strong>Independiente de la UI.</strong> Como la interfaz de usuario suele ser el elemento que más expuesto está al cambio debemos asegurarnos que no afecten al resto del desarrollo. De esta forma, además, se podrá usar un mismo código para diferentes interfaces solo cambiando la capa de UI.</li><li><strong>Independiente de la base de datos.</strong> De forma similar al punto anterior, al ser la arquitectura independiente de la base de datos, o más genéricamente, de la fuente de datos, podemos hacer cambios en esta parte sin que afecte a la lógica de negocio, teniendo la posibilidad de cambiar una api por un webservice, una base de datos por una api, o cualquier combinación que se nos ocurra.</li><li><strong>Independiente de factores externos.</strong> Como resumen al resto de puntos, la lógica de negocio debe ser ajena a todo lo que venga del mundo exterior, pudiendo cambiar el resto de piezas sin que le afecte, como si de un puzzle se tratara.</li></ul><p>Como hemos comentado, las arquitecturas existententes solucionaban la mayoría de estos puntos y todas separaban la arquitectura en capas para diferenciar los diferentes conceptos, pero algunas estaban más enfocadas a la interfaz y otras a la lógica de negocio.</p><p>En el caso concreto de iOS, la más usada era (y es) MVC, aunque habitualmente esas siglas perdían su significado de “Model View Controller”, para pasar a ser “Massive View Controller”, al terminar siendo cualquier clase u objeto una vista, modelo y controlador a la vez, terminando por desvirtualizar e incluso elimininar la arquitectura.</p><img src="/images/cleanArchitecture/cleanArchitectureDiagraman.png" alt="The Clean Architecture, by Uncle Bob" width="800"/><p>En este diagrama se intentó unificar todas estas ideas en una sola, que fuera entendible y que cumpliera una serie de reglas.</p><h2>Reglas de dependencia.</h2><p>Los diferentes círculos representan diferentes capas del software. En general, cuanto mas nos alejemos del núcleo mayor es el nivel del software y más unido al framework está. Los círculos exteriores son mecanismos mientras que los interiores son políticas. La regla primordial que hace que esta arquitectura funcione es la regla de dependencia. Esta regla dice que las dependencias a nivel de código fuente sólo pueden apuntar hacia dentro. Nada que se encuentre en un circulo interior puede saber algo sobre lo que hay en un círculo exterior, es decir, algo declarado en un círculo externo no puede ser mencionado desde el código situado en un círculo interno. Eso incluye funciones, clases, variables o cualquier otra entidad software. Por la misma razón, los formatos de datos usados en un círculo exterior no deberían usarse por un círculo interior, especialmente si esos formatos son generados por algún framework en un círculo situado al exterior. No queremos que nada de un círculo exterior impacte en los círculos o niveles interiores.</p><h2>Entities</h2><p>Las entidades son usadas por la lógica de negocio de la aplicación, por los llamados interactors. Deben ser objetos que solo dependan de esta capa y que no deben ser usados por las capas superiores, teniendo éstas que funcionar con objetos más simples (diccionarios, arrays, struts, …) o con parámetros de una función.</p><h2>User Cases</h2><p>En esta capa, también llamada Interactor, se tienen los casos de uso, lo cual tienen que ser independiente de la fuente de datos o de la visualización de los mismos. Si cambia los datos no debe influir en estos casos de uso, al igual que si la apariencia de nuestro desarrollo cambia. Es donde tendremos la lógica de negocio en nuestra aplicación</p><h2>Interface adapters</h2><p>O también llamados Presenters, es la capa que comunica los resultados de los casos de uso con la capa más externa. Esta capa recogerá los datos del interactor que a su vez los habrá procesado de la fuente de datos, y los formateará para ser presentado en la capa más externa, ya sea en una UI, en una base de datos o en algún dispositivo.</p><h2>Frameworks y adapters</h2><p>Es la capa más externa y la más pegada a la tecnología que estamos usando. En una web sería el html/javascript, en una app iOS todo lo referente a UIKit. Esta capa es una de las que está más sujeta a cambios, y la que podemos hacer más intercambiable. Si nos enfocamos en iOS, solo (o casi) cambiando esta capa podremos adaptar nuestra aplicación a iPhone, iPad o Apple TV.</p><h2>Cruzando los límites, ¿cómo y qué puede cruzarlos?</h2><p>La forma en la que debemos comunicarnos entre capa sería a través de interfaces, protocolos o delegados. Debe ser lo más polimórfico posible y que no cause mucho daño el cambio de una de las capas, siempre respetando la interfaz. Si jugamos con protocolos haremos estas comunicaciones totalmente independiente las unas de las otras, y serán piezas fácilmente intercambiables. Desde la llegada de swift ha proliferado la llamada OPP (Programación orientada a protocolos), la cual, entre otras muchas cosas, ayuda mucho a este cometido.</p><h1>SOLID</h1><p>Antes de hablar de VIPER me gustaría comentar algo sobre <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design">SOLID</a>). Para el que aún no lo conozca, <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design">SOLID</a>) es una serie de principios básicos definidos por varios autores para el desarrollo orientado a objetos, unificados en este acrónimo inventado por nuestro Uncle Bob. Vamos a echarle un vistazo rápido a cada uno de ellos.</p><ul><li><strong>S: Single responsibility principle:</strong> Una clase debería solo tener una responsabilidad, es decir, solo debería de tener una razón para cambiar. Dicho de otra forma, cuando una clase o función es usada para más de una cosa suele ser causa de estar haciendo algo mal. Esto parece algo muy lógico y básico, pero muchas veces no se cumplen y terminamos haciendo pequeñas tareas en funcionalidades ya existentes porque “nos pilla más a mano”, terminando por ser un problema a la larga cuando ese método lo queramos usar en otro sitio, teniendo que recordar que también sirve para más cosas. Por ejemplo, si tenemos un método que imprime un documento, y en algún momento también añadimos ahí que se guarde en disco, si en otro lugar queremos imprimir tendríamos el problema de que también hará otras funciones no deseadas y que quizás ni recordemos que estaban ahí.</li><li><strong>O: Open/closed principle (Bertrand Meyer):</strong> Una clase debería ser abierta por extensión, pero nunca por modificación. Es decir, se puede heredar de esa clase, extenderla, pero nunca modificar su código fuente para adaptarla a todos los casos. La forma más fácil de extender una clase es con herencia o interfaces (protocolos en nuestro caso). Este principio puede parecer fácil pero no lo es tanto, ya que tenemos que tener bastante claro la definición de nuestro proyecto, y preveer que clases vamos a tener que extender, no siendo siempre posible y teniendo en algún momento que necesitar refactorizar.</li><li><strong>L: Liskov substitution principle (Barbara Liskov):</strong> Los objetos de un programa deberían de ser sustituidos por una subclase o instancia sin modificar el comportamiento del programa. Es decir, una clase que herede de otra no tiene que modificar el comportamiento de la clase base de tal forma que al sustituirlo por ella el comportamiento sea diferente. La forma más fácil de ver si estamos cumpliendo esta regla es sustituir en nuestro código la clase base por cualquiera de las subclases y ver si todo sigue funcionando igual.</li><li><strong>I: Interface segregation principle (Robert C. Martin):</strong> Muchos pequeños y específicos interfaces son mejores que uno genérico. Esto evita el acoplamiento y fomenta la segregación. Es parecido al primer principio pero orientado a interfaces, las cuales deben ser para un caso de uso concreto y no demasiado genérica. El objetivo de este principio es principalmente poder reaprovechar los interfaces en otras clases. Si tenemos un interface que compara y clona en el mismo interface, de manera más complicada se podrá utilizar en una clase que solo debe comparar o en otra que solo debe clonar.</li><li><strong>D: Dependency inversion principle (Robert C. Martin):</strong> Se debe depender de abstracciones, no de concreciones. Esto fomenta el uso de interfaces y es algo que ya hemos hablado antes en clean arquitecture, que debería ser la forma en la que se comunican las diferentes capas. De esta forma unas clases pueden interacturar con otras sin conocer toda su implementación, usando, por ejemplo, inyección de dependencias.</li></ul><h1>VIPER</h1><p>VIPER no es más que una implementación de esta arquitectura, orientada a un desarrollo iOS. VIPER es un conjunto de siglas que describen las diferentes capas, View, Interactor, Presenter, Entity y Routing.</p><img src="/images/cleanArchitecture/viperDiagraman.png" alt="VIPER" width="800"/><ul><li><strong>View:</strong> Capa que “pinta” lo que le mande el presenter y que, mediante los inputs del usuario le pregunta al presenter qué hacer. Esta capa tiene que ser totalmente pasiva, lo más “tonta” posible y tendrá dos formas de reaccionar: a los inputs externos (touch de un usuario, por ejemplo) o a órdenes del presenter.</li><li><strong>Interactor:</strong> Contiene la lógica de negocio de un caso de uso. Aquí se manipula las Entities (modelos) para una tarea específica. Como ya hemos dicho debe ser independiente de la interfaz gráfica y debe modelar lo recibido de una fuente de datos. Al hacerlo independiente de la interfaz este código debería ser compatible para desarrollar, por ejemplo, para iOS y OSX sin ningún problema.</li><li><strong>Presenter:</strong> Contiene la lógica que la vista tiene que presentar y reacciona a los inputs que desde la vista son mandadas. Esto quiere decir que le dirá a la UI que tiene que pintar al recibir la información del Interactor y reaccionará a las acciones de la View (UI) para hacer una navegación o pedir datos.</li><li><strong>Entity:</strong> Contiene el modelo de los objetos usados por el Interactor. Será, normalmente, un simple PONSO, o si estamos usando CoreData serán los NSManagedObjects generados.</li><li><strong>Routing:</strong> Contiene toda la navegación de la app. Es quizás la más complicada de entender al estar acostumbrados hasta ahora a hacer toda la navegación en los ViewController. Este Routing (también llamados Wireframe) son aprovechados para hacer la inyección de dependencias a la hora de crear una nueva navegación y presentar una nueva sección. Existen muchas formas de implementar esta parte y suele ser motivo de discusión de darle o no más responsabilidad. Lo importante es que en esta capa esté concentrado toda la navegación de la app.</li></ul><p>Esta separación cumple la <a href="http://www.objectmentor.com/resources/articles/srp.pdf">Single Responsibility Principle</a>. El Interactor es responsable de la lógica de negocio, el Presenter representa la interacción con el diseño y la View es responsable del diseño visual.</p><p>También es importante que cumpla la norma “Dependency segregation principle”, ya que a la hora de conectar las diferentes capas deberíamos hacerlo con interfaces, protocolos, y de esta forma depender de estas abstracciones y no de implementaciones concretas, pudiendo de esta forma cambiar la implementación de una capa sin que afecte a otras.</p><p>Los otros tres principios también deben ser cumplidos, en realidad cualquier arquitectura orientada a objetos debería cumplir SOLID, y aunque no sea fácil debemos obligarnos a ello.</p><p>Si en algún momento no estamos cumpliendo las diferentes buenas prácticas y normas no debemos tener miedo a refactorizar y siempre intentar mejorar el código. Si no sabéis qué es <a href="https://es.wikipedia.org/wiki/Teor%C3%ADa_de_las_ventanas_rotas">la teoría de las ventanas rotas</a> os invito a conocerla.</p><p>Para terminar, os dejo un poco de documentación y bibliografía en la que me he apoyado y basado para escribir esto:</p><ul><li>Clean arquitecture: <a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html">https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html</a></li><li>VIPER: <a href="https://www.objc.io/issues/13-architecture/viper/">https://www.objc.io/issues/13-architecture/viper/</a></li><li>SOLID: <a href="https://www.genbetadev.com/paradigmas-de-programacion/solid-cinco-principios-basicos-de-diseno-de-clases">https://www.genbetadev.com/paradigmas-de-programacion/solid-cinco-principios-basicos-de-diseno-de-clases</a></li><li>Clean Arquitecture by Robert C. Martin: <a href="https://www.amazon.es/Clean-Architecture-Robert-C-Martin/dp/0134494164/">https://www.amazon.es/Clean-Architecture-Robert-C-Martin/dp/0134494164/</a></li><li>Refactoring: <a href="https://www.amazon.es/Refactoring-Improving-Design-Existing-Technology/dp/0201485672/">https://www.amazon.es/Refactoring-Improving-Design-Existing-Technology/dp/0201485672/</a></li></ul></div></div></div><div class="footer pure-u-1"><div class="pure-u-1">© 2021 Alfonso Miranda</div><div class="pure-u-1">Generated using <a href="https://github.com/johnsundell/publish">Publish</a>. Written in Swift</div><div class="pure-u-1"><a href="/feed.rss">RSS feed</a></div></div></div></body></html>